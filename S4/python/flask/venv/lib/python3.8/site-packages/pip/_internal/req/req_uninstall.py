from __future__ import absolute_import

import csv
import functools
import logging
import os
import sys
import sysconfig

from pip._vendor import pkg_resources

from pip._internal.exceptions import UninstallationError
from pip._internal.locations import bin_py, bin_user
from pip._internal.utils.compat import WINDOWS, cache_from_source, uses_pycache
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import (
    FakeFile,
    ask,
    dist_in_usersite,
    dist_is_local,
    egg_link_path,
    is_local,
    normalize_path,
    renames,
    rmtree,
)
from pip._internal.utils.temp_dir import AdjacentTempDirectory, TempDirectory
from pip._internal.utils.typing import MYPY_CHECK_RUNNING

if MYPY_CHECK_RUNNING:
    from typing import (
        Any, Callable, Dict, Iterable, Iterator, List, Optional, Set, Tuple,
    )
    from pip._vendor.pkg_resources import Distribution

logger = logging.getLogger(__name__)


def _script_names(dist, script_name, is_gui):
    # type: (Distribution, str, bool) -> List[str]
    """Create the fully qualified name of the files created by
    {console,gui}_scripts for the given ``dist``.
    Returns the list of file names
    """
    if dist_in_usersite(dist):
        bin_dir = bin_user
    else:
        bin_dir = bin_py
    exe_name = os.path.join(bin_dir, script_name)
    paths_to_remove = [exe_name]
    if WINDOWS:
        paths_to_remove.append(exe_name + '.exe')
        paths_to_remove.append(exe_name + '.exe.manifest')
        if is_gui:
            paths_to_remove.append(exe_name + '-script.pyw')
        else:
            paths_to_remove.append(exe_name + '-script.py')
    return paths_to_remove


def _unique(fn):
    # type: (Callable[..., Iterator[Any]]) -> Callable[..., Iterator[Any]]
    @functools.wraps(fn)
    def unique(*args, **kw):
        # type: (Any, Any) -> Iterator[Any]
        seen = set()  # type: Set[Any]
        for item in fn(*args, **kw):
            if item not in seen:
                seen.add(item)
                yield item
    return unique


@_unique
def uninstallation_paths(dist):
    # type: (Distribution) -> Iterator[str]
    """
    Yield all the uninstallation paths for dist based on RECORD-without-.py[co]

    Yield paths to all the files in RECORD. For each .py file in RECORD, add
    the .pyc and .pyo in the same directory.

    UninstallPathSet.add() takes care of the __pycache__ .py[co].
    """
    r = csv.reader(FakeFile(dist.get_metadata_lines('RECORD')))
    for row in r:
        path = os.path.join(dist.location, row[0])
        yield path
        if path.endswith('.py'):
            dn, fn = os.path.split(path)
            base = fn[:-3]
            path = os.path.join(dn, base + '.pyc')
            yield path
            path = os.path.join(dn, base + '.pyo')
            yield path


def compact(paths):
    # type: (Iterable[str]) -> Set[str]
    """Compact a path set to contain the minimal number of paths
    necessary to contain all paths in the set. If /a/path/ and
    /a/path/to/a/file.txt are both in the set, leave only the
    shorter path."""

    sep = os.path.sep
    short_paths = set()  # type: Set[str]
    for path in sorted(paths, key=len):
        should_skip = any(
            path.startswith(shortpath.rstrip("*")) and
            path[len(shortpath.rstrip("*").rstrip(sep))] == sep
            for shortpath in short_paths
        )
        if not should_skip:
            short_paths.add(path)
    return short_paths


def compress_for_rename(paths):
    # type: (Iterable[str]) -> Set[str]
    """Returns a set containing the paths that need to be renamed.

    This set may include directories when the original sequence of paths
    included every file on disk.
    """
    case_map = dict((os.path.normcase(p), p) for p in paths)
    remaining = set(case_map)
    unchecked = sorted(set(os.path.split(p)[0]
                           for p in case_map.values()), key=len)
    wildcards = set()  # type: Set[str]

    def norm_join(*a):
        # type: (str) -> str
        return os.path.normcase(os.path.join(*a))

    for root in unchecked:
        if any(os.path.normcase(root).startswith(w)
               for w in wildcards):
            # This directory has already been handled.
            continue

        all_files = set()  # type: Set[str]
        all_subdirs = set()  # type: Set[str]
        for dirname, subdirs, files in os.walk(root):
            all_subdirs.update(norm_join(root, dirname, d)
                               for d in subdirs)
            all_files.update(norm_join(root, dirname, f)
                             for f in files)
        # If all the files we found are in our remaining set of files to
        # remove, then remove them from the latter set and add a wildcard
        # for the directory.
        if not (all_files - remaining):
            remaining.difference_update(all_files)
            wildcards.add(root + os.sep)

    return set(map(case_map.__getitem__, remaining)) | wildcards


def compress_for_output_listing(paths):
    # type: (Iterable[str]) -> Tuple[Set[str], Set[str]]
    """Returns a tuple of 2 sets of which paths to display to user

    The first set contains paths that would be deleted. Files of a package
    are not added and the top-level directory of the package has a '*' added
    at the end - to signify that all it's contents are removed.

    The second set contains files that would have been skipped in the above
    folders.
    """

    will_remove = set(paths)
    will_skip = set()

    # Determine folders and files
    folders = set()
    files = set()
    for path in will_remove:
        if path.endswith(".pyc"):
            continue
        if path.endswith("__init__.py") or ".dist-info" in path:
            folders.add(os.path.dirname(path))
        files.add(path)

    # probably this one https://github.com/python/mypy/issues/390
    _normcased_files = set(map(os.path.normcase, files))  # type: ignore

    folders = compact(folders)

    # This walks the tree using os.walk to not miss extra folders
    # that might get added.
    for folder in folders:
        for dirpath, _, dirfiles in os.walk(folder):
            for fname in dirfiles:
                if fname.endswith(".pyc"):
                    continue

                file_ = os.path.join(dirpath, fname)
                if (os.path.isfile(file_) and
                        os.path.normcase(file_) not in _normcased_files):
                    # We are skipping this file. Add it to the set.
                    will_skip.add(file_)

    will_remove = files | {
        os.path.join(folder, "*") for folder in folders
    }

    return will_remove, will_skip


class StashedUninstallPathSet(object):
    """A set of file rename operations to stash files while
    tentatively uninstalling them."""
    def __init__(self):
        # type: () -> None
        # Mapping from source file root to [Adjacent]TempDirectory
        # for files under that directory.
        self._save_dirs = {}  # type: Dict[str, TempDirectory]
        # (old path, new path) tuples for each move that may need
        # to be undone.
        self._moves = []  # type: List[Tuple[str, str]]

    def _get_directory_stash(self, path):
        # type: (str) -> str
        """Stashes a directory.

        Directories are stashed adjacent to their original location if
        possible, or else moved/copied into the user's temp dir."""

        try:
            save_dir = AdjacentTempDirectory(path)  # type: TempDirectory
        except OSError:
            save_dir = TempDirectory(kind="uninstall")
        self._save_dirs[os.path.normcase(path)] = save_dir

        return save_dir.path

    def _get_file_stash(self, path):
        # type: (str) -> str
        """Stashes a file.

        If no root has been provided, one will be created for the directory
        in the user's temp directory."""
        path = os.path.normcase(path)
        head, old_head = os.path.dirname(path), None
        save_dir = None

        while head != old_head:
            try:
                save_dir = self._save_dirs[head]
                break
            except KeyError:
                pass
            head, old_head = os.path.dirname(head), head
        else:
            # Did not find any suitable root
            head = os.path.dirname(path)
            save_dir = TempDirectory(kind='uninstall')
            self._save_dirs[head] = save_dir

        relpath = os.path.relpath(path, head)
        if relpath and relpath != os.path.curdir:
            return os.path.join(save_dir.path, relpath)
        return save_dir.path

    def stash(self, path):
        # type: (str) -> str
        """Stashes the directory or file and returns its new location.
        Handle symlinks as files to avoid modifying the symlink targets.
        """
        path_is_dir = os.path.isdir(path) and not os.path.islink(path)
        if path_is_dir:
            new_path = self._get_directory_stash(path)
        else:
            new_path = self._get_file_stash(path)

        self._moves.append((path, new_path))
        if (path_is_dir and os.path.isdir(new_path)):
            # If we're moving a directory, we need to
            # remove the destination first or else it will be
            # moved to inside the existing directory.
            # We just created new_path ourselves, so it will
            # be removable.
            os.rmdir(new_path)
        renames(path, new_path)
        return new_path

    def commit(self):
        # type: () -> None
        """Commits the uninstall by removing stashed files."""
        for _, save_dir in self._save_dirs.items():
            save_dir.cleanup()
        self._moves = []
        self._save_dirs = {}

    def rollback(self):
        # type: () -> None
        """Undoes the uninstall by moving stashed files back."""
        for p in self._moves:
            logger.info("Moving to %s\n from %s", *p)

        for new_path, path in self._moves:
            try:
                logger.debug('Replacing %s from %s', new_path, path)
                if os.path.isfile(new_path) or os.path.islink(new_path):
                    os.unlink(new_path)
                elif os.path.isdir(new_path):
                    rmtree(new_path)
                renames(path, new_path)
            except OSError as ex:
                logger.error("Failed to restore %s", new_path)
                logger.debug("Exception: %s", ex)

        self.commit()

    @property
    def can_rollback(self):
        # type: () -> bool
        return bool(self._moves)


class UninstallPathSet(object):
    """A set of file paths to be removed in the uninstallation of a
    requirement."""
    def __init__(self, dist):
        # type: (Distribution) -> None
        self.paths = set()  # type: Set[str]
        self._refuse = set()  # type: Set[str]
        self.pth = {}  # type: Dict[str, UninstallPthEntries]
        self.dist = dist
        self._moved_paths = StashedUninstallPathSet()

    def _permitted(self, path):
        # type: (str) -> bool
        """
        Return True if the given path is one we are permitted to
        remove/modify, False otherwise.

        """
        return is_local(path)

    def add(self, path):
        # type: (str) -> None
        head, tail = os.path.split(path)

        # we normalize the head to resolve parent directory symlinks, but not
        # the tail, since we only want to uninstall symlinks, not their targets
        path = os.path.join(normalize_path(head), os.path.normcase(tail))

        if not os.path.exists(path):
            return
        if self._permitted(path):
            self.paths.add(path)
        else:
            self._refuse.add(path)

        # __pycache__ files can show up after 'installed-files.txt' is created,
        # due to imports
        if os.path.splitext(path)[1] == '.py' and uses_pycache:
            self.add(cache_from_source(path))

    def add_pth(self, pth_file, entry):
        # type: (str, str) -> None
        pth_file = normalize_path(pth_file)
        if self._permitted(pth_file):
            if pth_file not in self.pth:
                self.pth[pth_file] = UninstallPthEntries(pth_file)
            self.pth[pth_file].add(entry)
        else:
            self._refuse.add(pth_file)

    def remove(self, auto_confirm=False, verbose=False):
        # type: (bool, bool) -> None
        """Remove paths in ``self.paths`` with confirmation (unless
        ``auto_confirm`` is True)."""

        if not self.paths:
            logger.info(
                "Can't uninstall '%s'. No files were found to uninstall.",
                self.dist.project_name,
            )
            return

        dist_name_version = (
            self.dist.project_name + "-" + self.dist.version
        )
        logger.info('Uninstalling %s:', dist_name_version)

        with indent_log():
            if auto_confirm or self._allowed_to_proceed(verbose):
                moved = self._moved_paths

                for_rename = compress_for_rename(self.paths)

                for path in sorted(compact(for_rename)):
                    moved.stash(path)
                    logger.debug('Removing file or directory %s', path)

                for pth in self.pth.value·(i2K"$!ˆ$83„¤ ¡ $%( à!t6˜nSeáûoä¨(
 !@  "3ä*  à%p`h@ocgjR$é:îk*#K5ãâh#±fW-h8`uz.]t#loô §3¥. biv<*emüÇfdvy!åf%K $ ~f ^nhO_õèV%G~rÏ#Yµ$  ÄddŒ~erco{%9:
  ,¡b`((+àTgrU`9gomä->hbmlN)	 r Ph² ¤GèSğ!c{ { Jc(ÙDdl’$×~um$1b Ìgåo`u¢qÆa!T:lõút'ã5r$Kcïfxàéã½I+°2  á#2""fJ"`0tã¤ 0gáf ]%8gqzpù3lcd%±!|ÈÓI8  *b  h "$ d£@dë e;©wdr,¢Cbå6G³#][cS]#&h_(ŞWoA"(±C"   p6Ae\æçd)`¡tY{~
*€$¤`‚$$«") `ibeet~ ‹$¦$3€   ¢0 hogwR>mîvİ:mwo-NÀ("&à(1¨8¢ 7ët, h tçì}_Lfc(	¯e 
dè0)@ ""  )( is$p%üè®yo¦ËúìMi2K/íøyadh0Ç®iKØ-:µ .a+¢h"`@)(1 0dogUòx«nÎl*Z xi©
	 $(h !é$ ¬/”Cõ³jş{e
  jl ò`¢ &$(w!$eËòml}VA#®s!øîsûYp¡?$+¯)dv­qcWNyrm]vTqt&haatyfw	ZelÆ˜ğãp s°*&`  aô¨eü“dJ»(€¼ 1 °`3¬ 38Î8ò$2âos("M~h,àæi3q#|1A.L`ğjù"dilew°$h@ø(ice giv' ô ;?.à 0'(a ()	c!$`´%Ğuå®
 jb !(R `m0&}<x,İ{ÇLfôE L¤ò5Ğ(óelgôQØ7)¡Z @   2 l.UhÆ`_³ryRh<RzBtNA :0„€  dis0liY07+a'î¨sg=/táØ6-g)e¼'Z%ie|d¡b80¡0`c”dcc(ldq.cWoül¼oTò%îûhe!(i*Õ(t`Pd`¨Iúñl|{-pşhm¤+C>8÷mlèVqJkà:ˆ¡a` - b`_Ä¨2ygñaI×oul%4ä]d¡2$vo†g)«¯mdb*théKb(1)dâm>9Z%0{G}N_ZK1ùe©$el¤*  ¢jæ0/e2b.Wå	
":
,à"  0†(_`LgPî( e—éél"av7émHY"y·æI:),	skmqr1âsß~¯“]Reg%ug©Ïgjfô5~hs©+Ãb ò` (&0sÄtuR« !;k)%@r¦v'e5-HrˆW(1, (¿Y¼€F.§!!/½ ç}¥

èˆ0­.af {omngyoªr4MF);Œà ! )  § Tjpd¡(«$	jNèÑ(` !!¤¢"¾RoxDT(Àâ#e.÷&sh%lãesbø3=vhoóĞ.1°a!deñ zgíon% k¿"*3
(¡0B¼$ hf8„n´¡7%,'.Å'~dfècqh[oc)\_bOLLf`sÚÊ$ #!&&!%$¢` lïf'ec.ep³e+(
h 0 2bb<8$ 1( ªàö?xl¢_Ff,bqc$õv:!uE#*nLuaîm~1\jLXçä“,
& !50 è!``°(  `mìf¯6÷4«vF/jlbü^f`m,:(¨¸$*0
m›(
0@€@(( !%$²@5zn*8  r"$ HwuKu°niz¦oÃ¡bçDìinZ bickõ/}¨óVflí.w¦½a óuïF®ht'pÓjLqTKìñ|'³  "! ` se|vnxç§gdÄO !$hwæbmhL;aoi2xÊ< jd¡ "fnw Põx iìx2y`f/p`èval}E7iúš$0
 p `¢$0  `tp¶ób,ìàa+º>
(»l¢v"gmOviğj²EN ;
§¡(b 
 ¡(Üıtg:!a g¾±NO'ëBdp(! $1 ²"¢F~}m~e Ôipg{Azy°ëAVadIê> B.	dÄ%÷ç(g}L¬0no!|o+g-b"fee7ò[irüé/#
C‹ ! ( sehv.Mofh`]ÑQajõ.A~áåaf¬)Z$   „p[Ss¥-Dè'g
H  laób–wm]4msôèEmv* @}wp)¸#0 â8,#&tÙ!e6 -DµÓL~iB1.io(€N?ˆuŞy&U|ddì€=}n]AT"7²abA jpi5pÿrit4=âbkÊl)ê!bmßtaEë,v
[vlNb@tio;), ( '¡!v!mm` dësl~itkì`Gcø‰àåwt)*Š ( !xò!`("nNe&,ò,3blÃ( b4r(1d!$ 0 0à ¢\(l7îA(su`m|kjF $c E4¥S$ ïuõ)ibõŠEdöA·ÏÆïçLth	2"n
 ä! ˆ¢a Š& 0 * ¬éÔkÇP)${ ,¤`(¨0 H6!xa!Davğ]¸ÇT,
 ¡Ql( cÁ¡ "€  (w»nr3åFh<}
"$#04 v(!0))È  à²,q`Â$BÆdUpê`áåuxäãwta‚R!  <¢nàé&"vis^pédjkh k0 †5¢ p0é^ vç8óç^.gmeceçßdaTú&¿tÖl¡±<*0`0Dm( xhhp$"4  ª 0 %$fd),zdd& }SbGnìyc.Bc|ßzhzlh6pîéoã0ådIÂ"(y2¡,4.`a€b¨4­(¨a†  2 "y2dº=8‚!   0ªa ¢aAö/g$µ2.!nfo Ğ!b!!6 ¡ 0È ("Xç_ğ{şy®wNClMH®C-qh}<?¬wŠ!`Sàö)úx8yO$s,-¤{tán$as>:gùcra2x.d-1	 `,:4,& !(  ìë#p/û-}cê6a0 !("(T!$ 0 ÊqiÓU_peöj<2`¢ ` ef*1. ‰¤Ú °D+,0ˆ  Ppç6çRl&âlcd%{dš ˆ$`$À  pB5Lt_t-_raO6m  gL'ˆ¤id"®b  ¨` 1kÕü%øNôdöc_¦mnoà7‚fcalc*o^@!4èìz[¥Ø(&*=8  3 d'daís({á'M^H-.kÿ¥gG)nDo 9f{u.ygõ=hnímçWcòoáp,bb1°`w 9rnfWvaoWÚGdó4tkœ¦SDålske diw?®Ğóozuc§ULioui-’´3ì)"  gÀå_k÷q~cÎlwu3`7ô0ttzg^mŠfi``ng¸o5xd|ø^utìavuiòQfau_ejgk1
ª  €0)01*¡cp‡§YLNb+!3g`fo u%_uu4it÷àë~q\a%.ee 4A©»ÉGå
$(d¸n,J0déÓzwTñns''B&îM 9oxe4tZ)íStôsj|iem|²'Ògvi&LNm=9<(`¡" 0 *znÿí3r#<h8Êä3m1"LrdàP dn(=gTUe2 sŠ{*1X¨oá`$©bd]ZG4m(nA@énith} $b40#3)mdÂq`[ıew¬ãáé$ÿDÑas¡tå0ônYt3uall phgnc$òö¥nvl=@nçwebtlÄv}úPácÎ
ã" `%±  iG¨,ag§ö!?ï_g{y÷ºc(!jddI]u>dgBUhnbo&eJoÒ÷mX4ˆª.eCw«=Jbv¯` ^ôä¡cÄ  !‚"$p! ‘mYC!dz{W,eGÏyztlE{p3vs4èple>%låpVvoëHAn+äg7_im&/m)2I  à$!'   $ if!irõ.g]åWilzo,Ífdwwst
 4ev·lr^7gciqKj]ewQönk(6i't¢      ¦¢c,UZe`i¬ Oeó< ùît exd%ôEloPOEoïYìkn~ s@yl($ ((a `¡d   T`äéÖ4nsµ,My*Á$ä`äiot*ebgViofo(>@`(58@rc ! i&lÅqsv/àKu˜í¡\aâa|A(oIŞåid,íf<dê~åÓ*t\6æ	 $­` `d8€¨"!td 1fÎá)y[p§a.lmlkmQúvài. dló6ïô&]Nl|!lsz((+„@€¥#  4"($!`*"©b" 0aiËspJn|dt-Wédés*5Xt'i/ùP`lànjFa{(/z*‚¤ p*2100¢  2€$!h00itl*, ëu,pñy`öS{8it  .(d& • a (ad Bq%  $`  !aqº¸áÄb*JkËç(ôyavå#t[hnvf<‚yNp<åÎlAt_v©üE'
 ˆ  je!: 2¨/ "7@ %!0°@"@¨@¡"*`  t´43$0 Xytês]6Fİ{Ueeg¾YlD(0Ñô¨r*@ …2 `d ˜!ä ¢àÎyÈMÅ9 ee8a¨ğFsŞ"&¯f tÂe¿ lMb'şdOKkH$ D! ¢:&   / ï²#Ôr#p÷aôh0=,ri^fEw_}pWi?ì,e0õæâgklì±)l`nPgaä/=	2u£oÂT$OuQ{mlæ ! f&„ " ¡H$#¢/f&°)qà(  €8!((,8)5Mh¶!|s‘t>i#pßwpadKñaS¢vp]pÓr5æ~|y5'¨:Œ 4‚!A  `  !"!ª"uFb{B´+à¡s[~güid`Ö!)Ed%ESbac_Tayi¹bm²*Vjı7:::"¤ %à aã`d 0j0¬("NS-e p©}-0àbiuu.ctìepøáLjk êEomstIfe[\sc:ñ"t>u*4oŠ !,HC&"Tf!9&5$atA4+ 5p -`l ¢à  f#5  èÎågusasçs i'—U° ! ©¢ $0x°$0"/!öïi_éOå4,}PÃG`kş@[$; %   b`""`
@(€   `.ir4`ok,xŠ€ 2% @g¨#°k(¨(@b)*`0#`à¹I®@HRp67môOoå!lhôan‡öEpÛ¬x~äîn<pü f«PìiTlÁjl÷)) 0 " !2   "’ €2ñà )  i$`ú ñ®ä!t è¯tCel$n`-…rRKçåCm;  (£‚ .*@°"2"  à `rÖ(!y îs.påõ(·®šmn,„XsTªMJcaqÉmn< 6ëp`|e/vQëg9e $d& $ydh  x  ` ú{|xöşíbïì'fE.`ôT"0á$`ä4"  x?x è`2¨²  |t Ue&lr_4o_øáeoru®pÅløåuh$+ w,1x'	(4l#0( 8pœ%(  ¤0tctèw[tïßr­mnWd.aÅLpeÜØ¤*!'lbü''( $à†r`²!`$ ¡ ‚à2€ \p#0èq_d~_wemorE.aúlhPãtn!+ &;ñyfc|Îc85d`Ê@eíIg i3àõeympß'g×mNfM¿ p !$ L!#  5aq3}$Ufo-1do$ù`m+ntd{²¨‚ -b6"a p&d” 
"kbì(Cd u/ozSfA}L{årm^ ë¼dIRhah¼IR7%6+­w`ilñtnl+Dh`WmJgrt(f0( °`0”€ s£@v,¤addµ`O(E r`N.{\1iwk%Rateè9!&Mporù­Ja`?0iãl ß¯ìEğ¡bÅùon7`jéô    5240 1$"à 
doè qiFè¨Ap-wô%|elÔä/£ebäYHá ptuhe(!?N+j“tqlF…V~vLe5 
p¬B"$p  $Å` àğ$ àj0',-st®¦bÏ*%gE_lğãfâ
¢@ ") 9' 9 !$­Š$0„ ä2!0é(¡!i+àä 1 Š l)fæiwr-hkéqd©FN¬ujæò3kv@|e.e-bFió‚   @`a%* pp!f°PE!ËyÇe xôemd%Pdr| eJm}_hşãv)ï¬Š i4#% ¬d8*æĞ1 ba*o+t$=ËteH€ål d8½4&e/eO'£o% íekdù•h°!A)¢c^$c|qAàPEÿ1r!RsJ` ¦"$<à¢8 & #=MG: btõbtn{nv/0ª^I91-Àés6.DäN ô}cOTepd­oNS-7®6Bc3$dqÙv*66=Gfj°"¸±l+! 1p@a!|y6mËrtÍöu>h¬ôdítvd:mvb/FCJ%Œ$h$€¤ 2vcszVHJ1å#Bdgã# "}{paTü®vSŒ1T*dió$D·³12c÷z+FáM£( á` &j7‰<uGrlOxkzŞ7v-cxvè9l$.{nTåö:*«1nmwÜ ·°nHKñ~¡%g«­j{Pîeiiiv`oï-ŒØl´ " a¾`#‚ Q0& 
  "h<t ¶ 8a$-(  $ q`¨4‚qSs<i~·6UM|At@#9ˆR"00`84#ğ dô "su,×ş$,'ú5m`D![pök¨}co8;)lz>íoì_yf«¸ƒ§=§(+Ds»I_¨n3D¡L,ßawg:*
(¢â %`$e év(dfGOivbkLux9+öraAaF ¥#6Øn\EgzhïfnîgnD{'M=ø(£.ëq|/hnæoù)JB@    t!9)$hêbs{¥Ìxi~a}&inófa,m`ölgfp	÷p2 `é¢t)8$"1 à" à2&h'€%P0òm4 AÛun2dwo8f,atå(thğê-
hd   @$uù)f4`pçzÏ5†l'g]Dmnc¾&a!„¢` ¢h; ô§0Å¬Ğ¥l
!a 1 E(b0€	uémè?pän(@e—eNkpowg}inK,zv'©€sÒf`è2!`*‚ ¨ 4B`F:",`n+_tgÈ||Q")0.Co;äx NïrióapGÄh®rõËdd-,e8>szy ,-,%2a@¨ $¡  `t³6xv©8lyjg\Ñ_evtE0¢=»¡äJóZ.åoãAMk™¨„)X
  J ©¤ `ìğà $ "E7g?ˆ*|+à)s `iS+hÍTeaÄjh²`l£ftdlito)tago {N)¥û$¦  (! d0  ’$ (! ·a6"!5)/r! JhmO«^pOãn44s)hdkgÀåeàs`#tí,Pms8 eaq^ª$seAty,U  `„1 ¢  ’+
"àTI$$0@ô¤ 2
b|hq^doVõı.>e/©dç0§ERfxo"×cvÅONiF8¢,!¨0(& zŒ$° 4cqy{éNs4a
,ÍXFèY8Oapat`í~m5j¨a0@7á/Ui3o¡må*äerU.e gEgAhi~z)Fm F0 d¢"¤(#0¡$@2 ,@2n ¢@  (i$a81("©&$!40$/eƒss qns|pîl,pôXkl,0(`&F$  Bf8Q6hóßqoawmÅ^eîõdD×Y``$EqS;Ãiîr4 |ÿ-lÊná))b.lnaAEH:!

¦8d4  ¥1plİa>J$0¬1ä< !L!hï'oe³Veâw#x+ p,¢¢¼t."0¡ Õ&'O'V@ru;õ(Koç(tÏ!]î)nw|e&s4b%b4¬\h·qoº Í:¥9%  "€(©$ $$<(!…D!2t`ö uNo3quù}ö,
  `ª$!( # #ˆ
  	tzx`-5$ài*Äh'áeRyTjlg¢uC:mpzh½qcBñrõ3   @¸$e5	f2e*it>`#s_WE4`ì‰TIhcv%Ql1ts$-cfu"dI:vl¥d¼eÍepI+éS`iÑn#÷bRdpp3<²
!°" " 0(£ 1@Df#÷_|mp`Á*`tasD$]etcpa>|èâäEK:ˆ+sgöÕ¸'ãj:¤d° Šh¨U! v !  édatkó}İ]/k5âf å.ti{\i8¨ 1  !0
€¨!  tä‰`¤jhÜ×àmvŸ!fÉ6_u×oz‚"4B   "¢""!(1) %|ze>#hd4$( !,&†) 
x­jyZİ@éz1¿ rÉ.opqÛ$$&) ( €d @”!@¨râl(c·vn]17,ncÀ®uvf(js*sátxnƒ2(rIR]Dyr®abzi\6)- ¤&5)   dcªb¶é 2O@vKÆGMVR> `p ("*b`  æ¤1 (É! !Ğ%T`cW´~_zï·Nì(Gu&patmj*oi~hBk®[m`rV`Aazy÷t)h+p†._qä?!(^ !  0 0 cÉn.¡#ënbgl$fGà:iRTqA8& (¬ œ3#2áèº!^|+_Ğo­ktg(=~]Ò
¨ (8Wk~m%e_³+riòtr <8`kgplg3tZgîerX[,gp(gR¯gğ7'ãkf3{üE{ÒAc4tq*)`	! + ¤&=3#náu50elhbçşkre_1óğiplw*OeyV`)Ê#0#p4" ğ!!#>SgñëĞpğİui_kîisWNôeoækÆscxmU2_lões(`ióä¨Na-',*Æqd³t;[ $(t€`(—qUic…dGuácqøp=v×\9 5/+!uhjki04S E MY{t,ìe5^åÆ4-HÃiyp(çwjda¹£e<à×RÃàYøö57+‹àb &&¦$G>Rğ*9md!ûB²f}ûÏ7ã`c ñô¦+'y38: ´(° `0€!@ _širY`gÓM}^Xdõot&ãø6|jn)/ûcpD3ü_n!í)z(í{su*anDd%, Üsud{šJ"ª   d $nob scIv%[qåbipts_toMp4íÎza<B 5 `$ "8°1`ö%òhÿ]T/rtåfí+qd^ t&J |!  "Ãeu=s.$hEp óGõWU’Gcì¦5†jQdas	Uwé~yTq(xøÒHjtxaNkºÏfÊeã  :I'! "cef _ÖIlI\Ù_(0¦mæ¼"àöh¾&Ilu)
 d*,¸ %`X¼’&0S0bª1dş"Şoå>°"	!0&, y&$îu`îv+vcd"ésdk<ä-zğHfHh%+:$ 0D (jj($~f9wnÕN/n[tiolazilx
rò¤((I   ıd"$% ¸("*"!&Ã!gNme"eMNçí#uF?Ú)çv$pko0önbXOw=Ån”  úmeP4sª 1 8VX&wlÁe; À  â$p!+ !¦3$$@ğw,â*fA|c ==;tk]ilQ*$ 8#œ!D"Con"kåf-&e·d uw#k pwA0Ù0eú¤wí[aôóœ¡c6#é$$.GeiöØV£qöfd~difTs ½¨ÎKje02+ ÄùrfR¸İ8Zjm~±ü[Îi{tZ¨{T`õ=ƒ2!, lw<áaQDøuÈ`š Dnvr}!(*0$6(08))!a0Uy`ØsèP2/-¾ Vo&gJ" ‚ba)gm,HA[y ı{fPa0x®NpmCgcA(@ªğtá	K8(qb g(¬ÏfDVLoÀozs$0nZJ6adI¬Jkp}cgs(Pçkrç2lá´hmaEnf5i0xn(Uså$  " B0#búaâKò*`rh}R. *Øñq";q)koRg¡aB `|0 !N=3Éak!T8#t*lscóizU`b{WÌuu-Jd€)*¤!,&q4(ó!ûuvwøÄ%Í&sy<m)p`/aedL "Tf¸alHQt}ı æ0égâófõy`¤fmrL±Zò,` r  gL2laÛieÂB€ 0$± 0h§ oq}athşxìipjrmÆe$#r u{qDmòTC@	mr0er``sä`¬e{áJ³äB¥ágõIu"ycaãå	 
,  &dQnäâ,Â"÷omawscHuğexP¡pHó$v)3Î` 2étm
libpwiMaQ/©cÕ'$,(çå03ª{m\`v¯ª)é"µà4f;2ås tb{olepGär1gb3.¤+|gásG.Boes(.t re³ï7narI Bc(|Atî3áéf"pney¬$k/'v
¨3ì!"2óìa6e&íçb¡$´h~p#FLSI÷	pXy@erí">0—¢F`ô*ïKeæ}í'r:øv\Tw-c"Å\5harGP" ob: (P¨à 5 +`"TsìRVÅğ¬sÊöaöo4mµ:ã§h y](nj	2n7'8§0µT‘xoP2%^Hg c~(rtli4äX¡–Dğ!=$$))#bVKOES ùîl ïn /{dádh.[a“n²{Ş|(gJ|*ÚkZ2ÜZ("<2 `  h*o*Õúya5@al¯:ÓoVkpì!aí,"\T'*cÆ/&(bb4 `¨!€×wiæ.gL8Qi}g.!æ`8Gh<p{a
&$$0~oF úqpnne*D:p);‚`!à¤0 haĞ´|àE»¨© =¿`
g>eH $ !%` öl/wgì/tòÍcª&’å_o>`oCpp`Ibíg=2i%s Rfíå$´v</L´Ğ%hf)äklu!fl" ¤ ÃmdP0OrMN2W!lVF<Ìo,"#çFi.r F`š
l!!8!4² 0 `#6io [ws vwÁU`RóÔN'8çux2xE:,¥sã7$;ÓåS-U|jbG+th qznx‹à `$°!r$ r gknYs  äh¸pMIlÉïuq ñà¤ d¡ (%¢`@ 2q`¢&K!v}d~©OÄÍ`?`xÉ+en("`²! "Xd$ ny¬fwİpXz¥l&!ì(ef$†/zpìidå(I}8áLm2a.Jb&@ r 4& €E]niş7"¼%.Tø@/7B$°0¨*(`àjwõ:J%""* ?±"¢$!&Q×DeOo'¦=!\ë)  a0+( #íx,dn-¨eI3sa/|f`1aiexLs gdF&mngb00ğ"! 0‰b/xzíıanEjÏ| hh~DûZ0]/qîMs=YdÄ:mnd8{!<E.#­$e(*áug¤)!j²J   !a( d`yOaS=8%|ıoíCÛQY++ dmdbinA:é{C-dda*Z4dí¼ª,
'+Â "* æú¡mNvãõà}j¤zeDG/5nvbèÈ¸J * °a
$ $tvX:£!$q,08,,0" p `|&wïer=eçCUG.Pw¤mRyo' doşS]ª ­s§4 enÀr9;j 4 0F i@`b C(" áaî u+ReMz\gêÌx{«¤!î¤(aj%™êElcg"à "uşf­ØfmHÊ% èñ"%/!;e Ar/÷ptdR!nw¥EfROr:h9 h8,Œ6d!!0"0   eu3Ju2 2.0€v½tL oTõ¦è7¥\lD},dh"f&39+sñ´&H>*6 ( ˆ,%.$¢$0gè.u2a%TlultR
lxneƒ(. ¤f nWàsoúü~àrz+³GÈB)ÚIjÀ0br  /fu‘0Aº¡(¬0=®Yâ§nK4X  a ¡$g¸7$ôf2ìsa~ul_âczeb`cB Nç~íX"(Hp€i!  #!(ggg%JnM{¨ï
(    `*0 , "¦AAnnÿ^$bnl¾¸â#:y5lHËnges`pÏaér$$
k<E!W r`,mCta¦/"wU*'dÌq"5$   `!0$!¡@)J$`a`0"h€¡:R·öUr~!Ám35
  à¨! no—§Ø.lwJeoPnbOíjF $cçeæKpo(P2¤ö]<ôf3tàg;.`"Pîg/÷Ih§¹¤d! !  VjvhÈkze/ÜsàÌfnf)},/°g"?Üi¢ ç(:`9 ! ` b`"#æmjwB£„-myN'pªzEîd/âp&-D~lIJ%s¼jP!@*  Dê-tDP.dVú}ã
