"""Configuration management setup

Some terminology:
- name
  As written in config files.
- value
  Value associated with a name
- key
  Name combined with it's section (section.name)
- variant
  A single word describing where the configuration key-value pair came from
"""

# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

import locale
import logging
import os
import sys

from pip._vendor.six.moves import configparser

from pip._internal.exceptions import (
    ConfigurationError,
    ConfigurationFileCouldNotBeLoaded,
)
from pip._internal.utils import appdirs
from pip._internal.utils.compat import WINDOWS, expanduser
from pip._internal.utils.misc import ensure_dir, enum
from pip._internal.utils.typing import MYPY_CHECK_RUNNING

if MYPY_CHECK_RUNNING:
    from typing import (
        Any, Dict, Iterable, List, NewType, Optional, Tuple
    )

    RawConfigParser = configparser.RawConfigParser  # Shorthand
    Kind = NewType("Kind", str)

logger = logging.getLogger(__name__)


# NOTE: Maybe use the optionx attribute to normalize keynames.
def _normalize_name(name):
    # type: (str) -> str
    """Make a name consistent regardless of source (environment or file)
    """
    name = name.lower().replace('_', '-')
    if name.startswith('--'):
        name = name[2:]  # only prefer long opts
    return name


def _disassemble_key(name):
    # type: (str) -> List[str]
    if "." not in name:
        error_message = (
            "Key does not contain dot separated section and key. "
            "Perhaps you wanted to use 'global.{}' instead?"
        ).format(name)
        raise ConfigurationError(error_message)
    return name.split(".", 1)


# The kinds of configurations there are.
kinds = enum(
    USER="user",        # User Specific
    GLOBAL="global",    # System Wide
    SITE="site",        # [Virtual] Environment Specific
    ENV="env",          # from PIP_CONFIG_FILE
    ENV_VAR="env-var",  # from Environment Variables
)


CONFIG_BASENAME = 'pip.ini' if WINDOWS else 'pip.conf'


def get_configuration_files():
    # type: () -> Dict[Kind, List[str]]
    global_config_files = [
        os.path.join(path, CONFIG_BASENAME)
        for path in appdirs.site_config_dirs('pip')
    ]

    site_config_file = os.path.join(sys.prefix, CONFIG_BASENAME)
    legacy_config_file = os.path.join(
        expanduser('~'),
        'pip' if WINDOWS else '.pip',
        CONFIG_BASENAME,
    )
    new_config_file = os.path.join(
        appdirs.user_config_dir("pip"), CONFIG_BASENAME
    )
    return {
        kinds.GLOBAL: global_config_files,
        kinds.SITE: [site_config_file],
        kinds.USER: [legacy_config_file, new_config_file],
    }


class Configuration(object):
    """Handles management of configuration.

    Provides an interface to accessing and managing configuration files.

    This class converts provides an API that takes "section.key-name" style
    keys and stores the value associated with it as "key-name" under the
    section "section".

    This allows for a clean interface wherein the both the section and the
    key-name are preserved in an easy to manage form in the configuration files
    and the data stored is also nice.
    """

    def __init__(self, isolated, load_only=None):
        # type: (bool, Kind) -> None
        super(Configuration, self).__init__()

        _valid_load_only = [kinds.USER, kinds.GLOBAL, kinds.SITE, None]
        if load_only not in _valid_load_only:
            raise ConfigurationError(
                "Got invalid value for load_only - should be one of {}".format(
                    ", ".join(map(repr, _valid_load_only[:-1]))
                )
            )
        self.isolated = isolated  # type: bool
        self.load_only = load_only  # type: Optional[Kind]

        # The order here determines the override order.
        self._override_order = [
            kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR
        ]

        self._ignore_env_names = ["version", "help"]

        # Because we keep track of where we got the data from
        self._parsers = {
            variant: [] for variant in self._override_order
        }  # type: Dict[Kind, List[Tuple[str, RawConfigParser]]]
        self._config = {
            variant: {} for variant in self._override_order
        }  # type: Dict[Kind, Dict[str, Any]]
        self._modified_parsers = []  # type: List[Tuple[str, RawConfigParser]]

    def load(self):
        # type: () -> None
        """Loads configuration from configuration files and environment
        """
        self._load_config_files()
        if not self.isolated:
            self._load_environment_vars()

    def get_file_to_edit(self):
        # type: () -> Optional[str]
        """Returns the file with highest priority in configuration
        """
        assert self.load_only is not None, \
            "Need to be specified a file to be editing"

        try:
            return self._get_parser_to_modify()[0]
        except IndexError:
            return None

    def items(self):
        # type: () -> Iterable[Tuple[str, Any]]
        """Returns key-value pairs like dict.items() representing the loaded
        configuration
        """
        return self._dictionary.items()

    def get_value(self, key):
        # type: (str) -> Any
        """Get a value from the configuration.
        """
        try:
            return self._dictionary[key]
        except KeyError:
            raise ConfigurationError("No such key - {}".format(key))

    def set_value(self, key, value):
        # type: (str, Any) -> None
        """Modify a value in the configuration.
        """
        self._ensure_have_load_only()

        fname, parser = self._get_parser_to_modify()

        if parser is not None:
            section, name = _disassemble_key(key)

            # Modify the parser and the configuration
            if not parser.has_section(section):
                parser.add_section(section)
            parser.set(section, name, value)

        self._config[self.load_only][key] = value
        self._mark_as_modified(fname, parser)

    def unset_value(self, key):
        # type: (str) -> None
        """Unset a value in the configuration.
        """
        self._ensure_have_load_only()

        if key not in self._config[self.load_only]:
            raise ConfigurationError("No such key - {}".format(key))

        fname, parser = self._get_parser_to_modify()

        if parser is not None:
            section, name = _disassemble_key(key)

            # Remove the key in the parser
            modified_something = False
            if parser.has_section(section):
                # Returns whether the option was removed or not
                modified_something = parser.remove_option(section, name)

            if modified_something:
                # name removed from parser, section may now be empty
                section_iter = iter(parser.items(section))
                try:
                    val = next(section_iter)
                except StopIteration:
                    val = None

                if val is None:
                    parser.remove_section(section)

                self._mark_as_modified(fname, parser)
            else:
                raise ConfigurationError(
                    "Fatal Internal error [id=1]. Please report as a bug."
                )

        del self._config[self.load_only][key]

    def save(self):
        # type: () -> None
        """Save the current in-memory state.
        """
        self._ensure_have_load_only()

        for fname, parser in self._modified_parsers:
            logger.info("Writing to %s", fname)

            # Ensure directory exists.
            ensure_dir(os.path.dirname(fname))

            with open(fname, "w") as f:
                parser.write(f)

    #
    # Private routines
    #

    def _ensure_have_load_only(self):
        # type: () -> None
        if self.load_only is None:
            raise ConfigurationError("Needed a specific file to be modifying.")
        logger.debug("Will be working with %s variant only", self.load_only)

    @property
    def _dictionary(self):
        # type: () -> Dict[str, Any]
        """A dictionary representing the loaded configuration.
        """
        # NOTE: Dictionaries are not populated if not loaded. So, conditionals
        #       are not needed here.
        retval = {}

        for variant in self._override_order:
            retval.update(self._config[variant])

        return retval

    def _load_config_files(self):
        # type: () -> None
        """Loads configuration from configuration files
        """
        config_files = dict(self._iter_config_files())
        if config_files[kinds.ENV][0:1] == [os.devnull]:
            logger.debug(
                "Skipping loading configuration files due to "
                "environment's PIP_CONFIG_FILE being os.devnull"
            )
            return

        for variant, files in config_files.items():
            for fname in files:
                # If there's specific variant set in `load_only`, load only
                # that variant, not the others.
                if self.load_only is not None and variant != self.load_only:
                    logger.debug(
                        "Skipping file '%s' (variant: %s)", fname, variant
                    )
                    continue

                parser = self._load_file(variant, fname)

                # Keeping track of the parsers used
                self._parsers[variant].append((fname, parser))

    def _load_file(self, variant, fname):
        # type: (Kind, str) -> RawConfigParser
        logger.debug("For variant '%s', will try loading '%s'", variant, fname)
        parser = self._construct_parser(fname)

        for section in parser.sections():
            items = parser.items(section)
            self._config[variant].update(self._normalized_keys(section, items))

        return parser

    def _construct_parser(self, fname):
        # type: (str) -> RawConfigParser
        parser = configparser.RawConfigParser()
        # If there is no such file, don't bother reading it but £zåiô?"t*Bbh&|c   #&qi2qew Ádû{tû¨(4O!oï}"the`ÄçtI.ˆ%,¨° hc8$_)J%¢djaó W Ñclî1a¡g"@n`­iômvya/g ãÎ`!2a~lnw"3­lgs: ]"§r52cí `O®ît+ ˜+¨  0``o+Ep tn$óogdbTcp I`a|q:º„!4 &`q ir"ÿ.T`øK†CpE³Ôs`hn%}%-*(  Ì˜&@  ã0ğë{2(¢` ­€è . H„gäp rrer,!ddì¼fÂ!uei"$f- œ$cI!6¥x@eö?okaGhpgj:¢#O~v?dx‰$):!$l¢%¢),° "+`SÅe h&t=a:'^Ivius?ûïl.ğ[2á+`IPïi{s4a%7K¡! 0e â "(0@i% 1y)m"m¤V-hbã§uRÓtaof†hlaC*á|Ğ/owRedo-DÀl*
!!) a!0#0<   ª©!(*"3ea0Şo& ïFWbi~p©lvalôëZ&chFRacä|2ó*.æ{ü`0+Š0 `ì¤;*& h¢h)j1¬AÍ)`‚dkÀc,a®Fuy0ou'2zUdSîcgenblal³'#;""¤4, ¨` r0 $ä¢0( `aJà20 "¡!  ²! 2!0i db0eá=Fîá/-i 92   à`89e, c±8j$€l( ¡¡,Mhj•0v`¶oëa23mr*D“sovàq'$$úv/r?(0à`#  ú* ` 4d¨!b Qeç(
7u/~bo&8yubg-p|paNqI`?IvvuL3‹,8y3* H ¤5`4$À!a¡6 r5ásg¡Ãol)3eÒcğj8nBåx­CïtnTnfuAaDm	t5E(e SÛ2=eplgğ(Š0 ™ " dàbe•íPkpa3säzÊJ(q  fµn2Rlkc6_%´);­.ì}jT[÷áPr.c}F9*È¢´(à 5"(!`$ñ`a˜à$, )`^5n`
 ! 0'°¹ „ RhNadrdÇîf	qğTâeno$wrg­#án>éàOne|@>ArèaKms¾",!#  ¤` "*8 4 pä`dÓ)á,&÷OJFIo[kÙds¾Mvÿúj4\î~²ct(hğ½ - $z1,æ.n-rja&kzådşá9Ñˆ*(äì÷)x€Ye|b¬_wmõ|Æ>Mrwvq(¨)#¡"$" °#C`h(ĞadìfË|orwifoRep+¡2S sífª&@e9âinf$ avOic©:
¤`8`` à*# d}dE:ª=Dävì Ã||PDFN%	Dyv|-Rsup¬$S¬ú]M¸0«¾ %h+dY342,kÑ$ü•J (`b2*pa2.¦Êï:madişñ{d%,Diğ,|Ox!k[h±S5¡%vY±ué/¨AY wáõãv]o=afaxe$ke}Soth ¢ ètxåw oUõyna"p3¡w`æbåN,(% iMG(JOroíakE%ÿ ·ÄÕ`Söd2q¨H` ôà„ P^mP0(ò$£¦êõoapdLMQ# g&»oõög €­ cOzC-çuÚad¯=npîiÆec,osiUjFjRmj-}®4?!@ €ğ¡ ³² ñ"à. e! fj0Ìc, ym 0%;}J 
A8.,0 B*x`}gnA$@v¥h€{N(iqe½rJÑ !1  ˆ" ` ê¡a"=cecDi¯æo "$;(>~i2©Eo	z	olc]ä8H`m')"° â¤¤`t   !vzmAaZbfû&uİ 7hÇu|N &¬$$ Àbp EÚ|dÎm{ia}ë#çlZ ¤!õm¦`_APYeÇTr>.O4qws)rEH>-:c$ *)1$)"spe  kğm?`YTÃsibnez\dxMà[s|s©(32R]Õ p0"    æ&VEtñv~r@e$%ıktfgÖrciVh0ioh,…zr[rFzl%fdE|"v!vy SaÅü1pm&èi UÉq^ªq @$`(GÏrhk1q/b|å}`fn-m:y!6!a1N®)4…K{(!h(*   ¤ä¥d§ sèe|Ìr¥\<i„*vp¯`
 §²ªa%â °p!*~dkWi`utQvsvooáI&ÉRo&£$aîLŠ0DÁ e "B  "` )ëeÁş2M§Mm}ör j`nGt éî¡stmkçæ'r…%fv_å'måsŒ#"( r  à~ 6(1	2p á00b! cé¦ Sh5hìk'e_%ìÔå Î"! $(0 ` à$"-"{)e¬& y-ùk0ª*ntr¦X­PFkNÊ à ¸HZYú0P(Ys í× @!42(lt K~dä8% Tastt.à  ³%afe_lt%2OV7Fn©%CæÉmg¢,ãdın-xj$($ $0!5.|s°d8 (- 9l#kd%pihîgZTtømeÛÏénf,$\ésw›qtpTı]
 `" " @º¢"aeîDÅögV)!js$A®c0c+~$kgñzq4I.l"e)fms4áp±kal¥t $(vm|3Ñ+4.Š
`k8¨ ¢"Zèmû`ÓèMlÁ¤,4g°4{E14ì- l©KÍ i}PcSbbe&m vi`UùO,æÊil€ 0¨ ))0"(â
 (¡¤ h3)£"Cy	\Å: mOtd ¦+e`cO/fi|ÉïfS4_µtƒOF e`És"C5j§\`ïn˜I) „ ")!!mn{éFm
oqjô4¶epm¡HfH2I {n05`g `Mw½` zpyÍruy
`e "`¬!Ãojda7ßFihõ` s,à~ö{Tm</&,p8·	P_ÊBÎFOi]eG- VOşe+(° b" l i¤0ãnj-oŞöyìeiS"Îwt Æme:0!  (" +<$4˜kg~m `MoÄq9ÅGV,'JcnfBéGbalqw¢4 ¦!!( mlsašJK`! $k,‚P8ifeä%@ğNrc.QZ^läN®j£a0 coi$í7_gµidó!e`¥zOaï2doSãvXOj[Mhlas!
($¢€`(*!0 Eu |jw ‚r;u`W%$)Ard`a)¡çMÏcém±gonfyövğAukoè0ãˆ¨ °`h7Á%Ød kiïDi.cLÆBÉN$8w_,æ}å_Té8e8S«ineCOHORed\ “1d 1(á(uõJmA950‰aKlvafå~Áôíob&Je|, , b2Acbnth`[à'a$Ueqdó|ci&/MGbët$ğá.®)õïì#uAf('ht	
mt¨¨º0 ¨`80q8 ¤'ká~|g^~amÄ!ave­gqÆ|!şb2@hmpöó s?ní(ãOjy|@-
`t Â6(0 ¹
!  b0  +F 5aOEnlS,Âal_uäP^r]êæag:ˆ €  0dpàÀ4,¢P* *şwacy "oN'ooc×è6l°k{ ,ğaszag¦Uo!cz’¡e .ac"ek.'yg`nyNg " Y`(à`0kmCèä ûiO ã#å^.Á¦on&k|_.anE![êolæ7®Tšmj°bõ   e"(fhnCdm!2"ötaomjvp'enÎ©n9Rátyon6aS[ñ`]Qelukêç1í%i!{c! ¨`&) !4íaí o8LdZ*ÉPel%Ik6F(v{g9-æsYkc¥}sfIXM]) 0(d¤B#wsµhğsWu>g)NQ|x`CÅ}fkz#`@¦¢ v¶}s.$©H©¶ ”ep,Åkcvr afkçn¥:'Pczdâ]"  "`   #66\å2m¨Nå wøwCè 03z3%*xçd}_æyfYZ`  °$ (·òehgA2[`] pg” 
VPğsd{3[òa,J.I-!t]ofî~|  µ>0‡y(ob)kOô!|A·;A:óê00ëˆ    &‹(`3¬Tl©ğ©{~¯EL®Bní$$ ,TQD q~*çdoşıñhk`èuók` /ÿÂwosthIä$2 ¨ãxv$9  r9md Æ#oÖicgVgp)O¯Më|ïj *$¡ê 1p	()ì"°¢ `Ëd  aJ§	ÎÕuñl o 5f62 ï)fsyŒøœ¬`35æqğozP§ãÇ(èÃbx·.
G  d!d(¨-$$	B0`¤ Dc`#4TI(<ia"labhawö@tËéËripu p1ëqa *è* (°à¨«j%r=pn"pa så2vZ5jÊâ§ *à xĞˆsx@`êc ğá!pÃWã(eg¹Av Dêç 0kbtñ. 6:$äá`¬÷oar;ZásZilôì&¬Fdqmlb@æ@$¬ Pab{Mò©*‚)¨j !`¦$2¸8ùX!¬{tr$!z'o|bbgØaĞ2-r)¤ç<µn*naz$ ğ1 (´0fiD!BrÕrs%r[434ıB <l	aA#@`¡PB@ù	Ò`h)4d )&!è)dd¿piF2e_õı`,4$fÛİ+n0GCÍb.WeM4I6+cëÿ©qr{Íö›ª° €8° $`Da ¨®A\÷_M»d$äi)kË0!Ce¾s@Zpg<äbnidGrÁò7ÉrdtuâÈd 
