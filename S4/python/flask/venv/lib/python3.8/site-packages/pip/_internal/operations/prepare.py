"""Prepares a distribution for installation
"""

# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

import logging
import mimetypes
import os
import shutil
import sys

from pip._vendor import requests
from pip._vendor.six import PY2

from pip._internal.distributions import (
    make_distribution_for_install_requirement,
)
from pip._internal.distributions.installed import InstalledDistribution
from pip._internal.exceptions import (
    DirectoryUrlHashUnsupported,
    HashMismatch,
    HashUnpinned,
    InstallationError,
    PreviousBuildDirError,
    VcsHashUnsupported,
)
from pip._internal.utils.filesystem import copy2_fixed
from pip._internal.utils.hashes import MissingHashes
from pip._internal.utils.logging import indent_log
from pip._internal.utils.marker_files import write_delete_marker_file
from pip._internal.utils.misc import (
    ask_path_exists,
    backup_dir,
    display_path,
    hide_url,
    path_to_display,
    rmtree,
)
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.typing import MYPY_CHECK_RUNNING
from pip._internal.utils.unpacking import unpack_file
from pip._internal.vcs import vcs

if MYPY_CHECK_RUNNING:
    from typing import (
        Callable, List, Optional, Tuple,
    )

    from mypy_extensions import TypedDict

    from pip._internal.distributions import AbstractDistribution
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.models.link import Link
    from pip._internal.network.download import Downloader
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.req.req_tracker import RequirementTracker
    from pip._internal.utils.hashes import Hashes

    if PY2:
        CopytreeKwargs = TypedDict(
            'CopytreeKwargs',
            {
                'ignore': Callable[[str, List[str]], List[str]],
                'symlinks': bool,
            },
            total=False,
        )
    else:
        CopytreeKwargs = TypedDict(
            'CopytreeKwargs',
            {
                'copy_function': Callable[[str, str], None],
                'ignore': Callable[[str, List[str]], List[str]],
                'ignore_dangling_symlinks': bool,
                'symlinks': bool,
            },
            total=False,
        )

logger = logging.getLogger(__name__)


def _get_prepared_distribution(
        req,  # type: InstallRequirement
        req_tracker,  # type: RequirementTracker
        finder,  # type: PackageFinder
        build_isolation  # type: bool
):
    # type: (...) -> AbstractDistribution
    """Prepare a distribution for installation.
    """
    abstract_dist = make_distribution_for_install_requirement(req)
    with req_tracker.track(req):
        abstract_dist.prepare_distribution_metadata(finder, build_isolation)
    return abstract_dist


def unpack_vcs_link(link, location):
    # type: (Link, str) -> None
    vcs_backend = vcs.get_backend_for_scheme(link.scheme)
    assert vcs_backend is not None
    vcs_backend.unpack(location, url=hide_url(link.url))


def _copy_file(filename, location, link):
    # type: (str, str, Link) -> None
    copy = True
    download_location = os.path.join(location, link.filename)
    if os.path.exists(download_location):
        response = ask_path_exists(
            'The file {} exists. (i)gnore, (w)ipe, (b)ackup, (a)abort'.format(
                display_path(download_location)
            ),
            ('i', 'w', 'b', 'a'),
        )
        if response == 'i':
            copy = False
        elif response == 'w':
            logger.warning('Deleting %s', display_path(download_location))
            os.remove(download_location)
        elif response == 'b':
            dest_file = backup_dir(download_location)
            logger.warning(
                'Backing up %s to %s',
                display_path(download_location),
                display_path(dest_file),
            )
            shutil.move(download_location, dest_file)
        elif response == 'a':
            sys.exit(-1)
    if copy:
        shutil.copy(filename, download_location)
        logger.info('Saved %s', display_path(download_location))


def unpack_http_url(
    link,  # type: Link
    location,  # type: str
    downloader,  # type: Downloader
    download_dir=None,  # type: Optional[str]
    hashes=None,  # type: Optional[Hashes]
):
    # type: (...) -> str
    temp_dir = TempDirectory(kind="unpack", globally_managed=True)
    # If a download dir is specified, is the file already downloaded there?
    already_downloaded_path = None
    if download_dir:
        already_downloaded_path = _check_download_dir(
            link, download_dir, hashes
        )

    if already_downloaded_path:
        from_path = already_downloaded_path
        content_type = mimetypes.guess_type(from_path)[0]
    else:
        # let's download to a tmp dir
        from_path, content_type = _download_http_url(
            link, downloader, temp_dir.path, hashes
        )

    # unpack the archive to the build dir location. even when only
    # downloading archives, they have to be unpacked to parse dependencies
    unpack_file(from_path, location, content_type)

    return from_path


def _copy2_ignoring_special_files(src, dest):
    # type: (str, str) -> None
    """Copying special files is not supported, but as a convenience to users
    we skip errors copying them. This supports tools that may create e.g.
    socket files in the project source directory.
    """
    try:
        copy2_fixed(src, dest)
    except shutil.SpecialFileError as e:
        # SpecialFileError may be raised due to either the source or
        # destination. If the destination was the cause then we would actually
        # care, but since the destination directory is deleted prior to
        # copy we ignore all of them assuming it is caused by the source.
        logger.warning(
            "Ignoring special file error '%s' encountered copying %s to %s.",
            str(e),
            path_to_display(src),
            path_to_display(dest),
        )


def _copy_source_tree(source, target):
    # type: (str, str) -> None
    def ignore(d, names):
        # type: (str, List[str]) -> List[str]
        # Pulling in those directories can potentially be very slow,
        # exclude the following directories if they appear in the top
        # level dir (and only it).
        # See discussion at https://github.com/pypa/pip/pull/6770
        return ['.tox', '.nox'] if d == source else []

    kwargs = dict(ignore=ignore, symlinks=True)  # type: CopytreeKwargs

    if not PY2:
        # Python 2 does not support copy_function, so we only ignore
        # errors on special file copy in Python 3.
        kwargs['copy_function'] = _copy2_ignoring_special_files

    shutil.copytree(source, target, **kwargs)


def unpack_file_url(
    link,  # type: Link
    location,  # type: str
    download_dir=None,  # type: Optional[str]
    hashes=None  # type: Optional[Hashes]
):
    # type: (...) -> Optional[str]
    """Unpack link into location.
    """
    link_path = link.file_path
    # If it's a url to a local directory
    if link.is_existing_dir():
        if os.path.isdir(location):
            rmtree(location)
        _copy_source_tree(link_path, location)
        return None

    # If a download dir is specified, is the file already there and valid?
    already_downloaded_path = None
    if download_dir:
        already_downloaded_path = _check_download_dir(
            link, download_dir, hashes
        )

    if already_downloaded_path:
        from_path = already_downloaded_path
    else:
        from_path = link_path

    # If --require-hashes is off, `hashes` is either empty, the
    # link's embedded hash, or MissingHashes; it is required to
    # match. If --require-hashes is on, we are satisfied by any
    # hash in `hashes` matching: a URL-based or an option-based
    # one; no internet-sourced hash will be in `hashes`.
    if hashes:
        hashes.check_against_path(from_path)

    content_type = mimetypes.guess_type(from_path)[0]

    # unpack the archive to the build dir location. even when only downloading
    # archives, they have to be unpacked to parse dependencies
    unpack_file(from_path, location, content_type)

    return from_path


def unpack_url(
    link,  # type: Link
    location,  # type: str
    downloader,  # type: Downloader
    download_dir=None,  # type: Optional[str]
    hashes=None,  # type: Optional[Hashes]
):
    # type: (...) -> Optional[str]
    """Unpack link into location, downloading if required.

    :param hashes: A Hashes object, one of whose embedded hashes must match,
        or HashMismatch will be raised. If the Hashes is empty, no matches are
        required, and unhashable types of requirements (like VCS ones, which
        would ordinarily raise HashUnsupported) are allowed.
    """
    # non-editable vcs urls
    if link.is_vcs:
        unpack_vcs_link(link, location)
        return None

    # file urls
    elif link.is_file:
        return unpack_file_url(link, location, download_dir, hashes=hashes)

    # http urls
    else:©   1 "`_etRxäeÎQ¡cj_lV8öUurÌ1
!  : 1¨¡ , cìH|êh‹j£°¨(`(x!hGép6i‹f,
 ."# &"4   gub|OÃ,!&¨ $€` °y#d{_nl.a{şd­2,ª` ø­%&$ $, `jH!Je:…IeÃjlß-
f°t`¢!`)Bev(yj
/oa|_jX}T_}Êd(J!" 0mY~c¤¢!+¨t<e:$Sğ& ¨"dOyn¥nHífr)*!iöù,ej[Lo7n\`4åÒ
! $¢4aiõùty:ì  áthhu² su
"€:(eå`ds-1 y°U{díš&Op`ao®¥h[HashGó}*«>€‚àg³8|]Td2$(®&) }8û”uø|eJUupÌ¢ëttï`  !*"fDgwîlnaâ)okOjJsj] hät_pTsmå¯dŠv u#anEpğúKr)$DL so{qj* 3Z(a$üş7|zEq¨>  î{nìïa`åKHè)oC)Š30à2 fa<vpA&É$=$Ob.`ctHl3Ämf8dt|vW$IP- ìw.üoq/âmlãæa-}-
"b´ wa0< /péoø&y,mfathn 'gl%© Cs¨cknUEä_æml%z  è¢¥`  ¦kV!(U&o¡Hn2L¬zÎlgm8gajPhÿS{
 !à 0   %b(CIn4a/v›bch}*örkwí*citnë©R  #(/MF¨øqæzeu> * "èb8palG³)cYg[/dça¼.R7Ztaô~#æ8n/_pMd(ª" ( Ög$ñq~ æimg[8AdH>°@c7ÊuoId¤3múÂk.we*jeaeMr"oDm<#'ÿ®Egg$$Vmrõ#$!GG-j te¦a8lIkX/wjl_ád¤hr-EÉnÃ,($.wNMæA`_Fkp(#èbUI&r(:Z& $"C P}ğAºé-mIj¸‰G4r,9|i/n%ø_<1¯ á·]ä¯~,NRti:aá^77£iB"-(( abhdck(`oclHFaD]Eir FO6$pâ1Di/ôÓøQ¨dçjäÉTádòÙ½g!÷)Yha1pruğô)éh#A¬Œ "° (ãMo(¡8bkvR7%t"ä-ì%ktdï½ï$°hEquc iqc0peû)œåMqe2j¿L‹à* ¢*,  $4-öílk&_ñ`µe`ùlks>pyp|2bkInˆbkVllo_µY4©2<8_iBJşímmmmemå):²h¡if lot nr0H4j~'şÁwôqhf?_\|häm_qad`);  pA `vÄdbyN@'êe
qù ƒ Pæ1@
(Pa‚(Eo7+øêaäD¬("nEs)ù5 zM7ñ(ÉAtË`;‹" €îggqrignï8%Fxle!7s3'hdbåqd«f9ec¬j psbh,v#¬ fivfgïuD_h:9‘   a6(é 3hmR
  $d ( àtvh: („ æap$u*ha6JQãnó8-Ëk[aåe(f"t_qqth8eoSfpîifÜğà5`-
a"à( pN m|cÆpt ÌÎ5ZŒh3,ñ4(¸‚; $©0$  `l  lïfçe2,r`òné~k$á  €	P(¢@$`(( 5Äâe~)O…sn¼-d/gììá,eì0g<LÁ+1;¥iHahFE!bIiqi>b/ˆc% 0° Šf(¨ ( à'ViıpMwlkXtonG*"®¨¥0!" 4 "$ (!&+"$olomd`cthK Àd!§°n  ¤ 	@ˆ À`¢`($¥_Ñqné	jzoL|kaDWpa~ˆ!
  $ (|p%&veTµpz:VÊãi
!<$¤SItek¦ ÄowL(Mä`hiüh
qçñsS PåÿesuientFrıl1zmr(X:us|!{*& °5¢6Sq"QpRl3¡`8
e9ÿI|eÍeç< (¨0*#2šC‘ " Ä(' OÉi~y]$ (0,(:`s%hÖA b$ª (  «wiÑd7+r" *¡mrõz¨ãdxBP8b°l £9@m^o`¤Ï$r,% 3ipzpÅèGğd[g&lËsôPŒBè""   cx7_Dmr$ s!túğå,srr
2
(`V(¢¿heEL_l-djmÍ`×&yó|" G06qøc*pti{n}dûsq3]¡0 ( $h´b}iİ$e%=|a4in¨ &'h=y`e3 RG`.P°$¡ )¤#òuøYtrhKCdô,$ 32tc²c"rÿ#eÉzåiôntT AcheòTp c,0!°D6nooitey, 0#DtipE> Po^lçanEsÆ8#° ¨0(f)LdU2,"na+–y0e:p#kafecn&eB*,(  $ˆ Pjäqqi2Å_kï#°Å[l"²'TRBaz€È¯ïnè$9 0¢ <u÷ıûUy@â{m}g|` [aòeZ Âml4 !2+** è@  ((#e|{te (nnn„}ZÜGo.E
  â$8p  otùpbhwtõér%-dbvTvep!z÷¢h SMd©&_O­®yÔ[]h- 4à !€(hKi6-rxb{&iu(}8g6]dmz( (‚X$d÷oäg~"qiltOlëPüfr%yffGäh0
2">%  hbw`n†êÔç3Wd:tgjcR ¸rá{ßÔâe#aerª!b ¨$  `r%J¦FkWZÎoá|ç± hmErx?yddb ¢ 0@0 wàH‡*b/jdöv%°^{çdupŠJ	$` 0!2 zebl#KtkÊì9ç@ñoätàa3Âh+å“0motLc†b" u³9TEa0ãôo.!nìnn*-<kbq a20
  `(` 8 &"~§|!rufdl ñ&a°!S& åetep=åO-yiÅied},yb%r|vfpvNpybSIr'j0(  ¢ Bc%,fîdwUÏl'qäOtáp(hlor>üç#vfia>K`  0bÁ"(/ Shå0t`stmALmxaÃkö $.Öè,ˆfx¬eS°J<oñ\! Z´ }pIdq$æ"~-/Àl f`hZtDei$crEz`|¾0g``c£ ãwmatm^+vç¡qtAWgHlO$aiz óuza}E|°¦`Sex!zsı* tovõ?ŸkyeSlÉó`tk)	6ÈXafQ!aåv)iu!ï¾ìy2JuEpI(o!ç m%H p<aàkvesèoÒ pi 0Wjcõ|&Š!`#`1¡ásaŞ.whçajU@o³nMohfØEiö<¶FxeE-Zf{wOLoqlRlé’Ÿ
$$ d 10NgMˆ€` (¤!D!* 4tşì?beåqrpnbuØ%¥ü‡|/îIa`We)RãïtGw~q0sÀmA.Ğse|l9¡Ao É)u
3 $,!¨!!cK$#lIni$!i&*×A'Rá şhlìmjg2t0Xave ¯wíhµ|"!RGlév%sGà2u3YlT m~""`!(Š #•üx%!sj M¬`hucd 7åuRg= =`bQB0h!¤l7b
d  ( i` Ésj"uÉÌä0ë{íL`f@onq!èæowdp{‹p`0!( `s7ìÄnbM	>`_qó~~hüÙofj4 Qqil%Ûé{Ï,Ë7yïj(`0 ¡  ! £¨GHOgbh `oWhycfevky?ç bawáyYyEl?!0   9&@ikl6_saQ7éóAu*{ÿôlr¨½0òev_Ùãå_¢EQhAS*: .a¢´& %3dc8zamt0{Êcü#e$`mo uqr$YmtT¼¤ácmed±sh!t:€8sudgu#e_uKc~sy5ga+`vse{dq=v~rit(Ën5#¨FBSo0åruy*  àp$Înß$ïN,íapóJoqz,]óDve)sam'):+,`¢@A #6Ğyem90-"mxÀ'MooØ%4 ¨ ¡jK IP1!ï~CælooìAh%Ydy¢*
®`8€   À-cªrd`%jc ÆèlsU«. c dA")& ks$ğkt0¿åz{1x7,ÄFlf.d^}Dl-cdWæab!²@ yäa… `"l $qm|ern Vrg9¼ ¨@*&  ` e/cE2$#`ë´©£L¸§otìå"n u#fi+ÄHçk'şnea$Jä!fectïrq­	 „ ˜¤° ‘óeés'zYowfÃ}mavi'^Íãú2,*0aàH)#j   .4#Cmdlm(ê*4 ~)nfaer°qccl@s$lïFFmgCt DxváCu/ó?$§ó}&Â(`aƒ  ( ¡R.â-Ó­gD(caFgæ`/uo|iaLD`Øáh#`   %dåÄPzså\M:%m)~+e$ßòlqeirmIl5(
`ä  fetqÅofƒ2("2$ " *c÷ñ.£âc
öa°u]:hnÑt£êz!yuirEí~n<š *(!	¸Š8`&! ,§*n(óEZ¥*.®+f-zÒ@¤÷t:!Ã kstYjt}hınÂ!¡¦0+  "»PrBqczÇ õòíquñr/mäf6,0haö wouo '{/ êbõAxLwd&r2me weu
hIéiC4)1 "  ¢bó
®ã ) ã‚ c{qexV$vñ,iíli
0  ˆ	  `ei:1| Req/&in"
`ä¬0"":¢v$ÔÌN9!BvGğÏeh An5o"r5eN`ar00q[ãöcïmcŠ0u `ä €}b>loî{Îscèeme Ü &Vid%¡*$7  ,!*  `  Xe>ih]¢*énk¶@)øe^zTtL`! `0! ! ¨!Ynew tc\ogTq*ueqwƒmc(!“&/%faSpháq_pamP8bán`()J€¨, #©bLT÷…>
$ (@( àA°*pl­GF¥r/nrO‚&Ogd¬e0¶aLê `c: óIù(zyTHnó(v/qø
`¤`€ `47ét #é~$'"p_ÄmT"m:	"Š (¡ b  , ((A@0hv¢Ü(äeS}stç<¡tc#MCgE@ wpí n58dòi8t
d"1€  p¤!h`5!€mnÄT¡bôe -÷¤1 :í0,$gtgÅî ,wli¢tifíñèx#$wvrï0h  ‚ "3'$ do# íqs(>hÔî t(íeaëqicr`!e4amÒPc#2o V+ğ'c¯ Äh-" . 
|à `  c `·x.t)rÍç`oğot h Q`€ ¡*`0"FÀNkàyUqe`ìp"ÈÒ$m~ì{ wçÔ)dÖ8u$i{ "<d~ws1Ire|etQø*Ša 3"(¤   8#{su1vÃeW¤y{õ²³uW$yb)Is Oood™v(ac%±f e æq¾pZså>e`ñs_3nuòz£¤iB)pm¨6ªcóh'bVFmZ h $$d‰"hu¸QV%Af:  g«åƒëe}ô ãx(sdU, ˆtw1¨w	sc¤Ìiëdeû`vk)Mg.¨%Wåfsq/fFb$°h  €0–kïa¯nãIşTcfKM`s#ir%phogÏïdªmd´³4!uv î/ ì?dŒâa}l tá`#@ #`2¬$0@ g(iswal$kô`¯'	$€!°³†À  0 !¬6	HuE¡t@iÑ ~kh'\!p$i@e0w`Eh¦ôIu&G+2&an0%xhó4ihgC%`$p£¤ (("chpñ"+kcAò}dõe#i%e0N@$	#Du†wnq‚cT_d+vd‚àƒ`' !p (á"0éb°aw¾ãs|j¦gtiw:y(Qgnõatx,jon¸v%3;±.}r"edir}doSqr_PoAh'+ª 
e¨#ğ`  l¨  lziyEfhÑrefoíqxbÕidtÅijÏ1~OS
   $".0 * à¥pz$ ¨¨!BPLp(C 'qbcZgAel rixğraU·)Zem%Mtw`?ù# dtÖ dh"ea ( "9 ´$0a3 ª00«¨   Hşi>%|owwènwòu!øl&]hbE·4ÆrX1${}). VªaW`ió S *,0*4¤Ğ$# °$  „ ` 3nIkedñ<'õ)µN á*lÆb~jyz ivqpaoíáfËïl`Tr#pbfAièå,l
f ) *h¤à!  %& a! !®:hMÀ"yñ`bui‹g`:m{w66hb8e áj&n/d(ysemmF!`l ¢Z*#"$    j c¦&0á002ka{ $'lETdp~|eg> Tl`oWg€pájuTáBal=qnh3| `#Wh&ª2 (0 è% ( 8 '``Á  0¡0'eNRm'Tmvuq(*2e÷.{OePFl_Nrùa²D  $1  21`!0 *
 #d(0¤( `pÈ¡!odw $0#r`e0àaweèÔ gÃsm `lj|*ô¯e8b¥ÇH¼eOl rk¢T+Yî*¯gŒ  ""!(8  #$d3ÒeaUHòvea.|r!~# h!teŒánl6mJR5pïí÷5}\ÓÄ&icvn[m!4éft ärúíjf
`ğà 8$í!d° 3`ôKó.$ïô*ÁğI%.,(or¨d pmXt¥, õC fmjPRkÃe FfYE	4hT-q/vsmp4u b „ 0&` ( ôi8&Of:A¬Z" uZ_)se}èr:õlñN0Hq3ÊLIûkyIW')`#á ¡((	 (à}`2{mFş|p÷9se_(`çxeC<Ê!h Hb °0 p  8$' ÷U(#{Gm%bj|CO UhAg	•daw{u 2 jod	`­Ahs!{n7!æ5 ‰ j¦ `(  !%("jbssllgc^u/<band0!afnlpÔÁe|ãäyOn -b CoîRié]js8 }5*dHn
 "("(&°! À"" ""%% rA¨n4~d8ò~0K²\¢l¬Qs-$Pá$|l(Qsrïj%)d{y+?%~C¦=VJ  ""& ¡€  @!" 2(Õêieù(a n-sâagëuå\DlÄ3¬ bn~Pnam¹vO riA_“dà%rdWs!zŸ* °i* `!&:! h€ "'·ì%ch bßfew¥Lî04((8a$A ` ! `d léf".h^WgóË H" ) ( 0p 0#440 $¢çems%rTcBHa_(U>×]pzgptud(© %``@0! ƒ¤ 0 `ei~Ìlan@d+óOa¸irtioe[ykt0å*(0`)! :E( ` # c 6 ( Ceáa4F)â%c|lòsqrlLabpwJuğ8~LvS¬J	Jr@¢  #   0$)†id$n#¾fFe~ooPbSknalr5k)ì)`$e$ÎoX$q}Y,kòN0ynV'`>
 4"!  !'(%r€â (p"+0DÎR)ngetpec«&5;#ér#`~1oécG fwr rVs`Le w@ùÎ¥c¤zé'
bÁ  "à‚¡`b¤P" ° k RŒBó).j"ìu(<˜lga4d@ œimz*J{æ#d 2 sm£Wráti!óH=bnÌ²"|t:$!"AŒ 3¡ 6 fE` &0#(m` wa4dsHuÃ&8s !Agub±gIóilÁ!iq“I1}c:ìaW÷k&qe táU
  (p e&la8a¤` ,"°&ä1tUóB#š" `Hö  !¥,(.2"   PáÛ|)&  !¦.# h"$@(` (A"&Fkle8ÿ'¤TÒ@{"vrY,¥ $âie^)áLmŒ c÷ ğ?o¦t'g_sôai~))    4'0a! ğ1`h `c@ur+Tô*|HéÅ0nû6 Rd n'`PNîkeh.H( 00(! c`"!  .±³ãò vá=seìhë@©õO2kî`u»ª,ˆ*  ó€"*&b­$/0{qWèEs=Speqhñ3z53(ô;q4ßéúvurnÆ=nïp sÇNf®5a¸òIbo_è€è}r,š$€  „€ "`ği`"vFD.wgÑÕ©æ×|a{h5QĞáOt >u0èãahus[Š "`$  °¸0`52`¬3rJjk7ŞgG5(k£è-÷ ':å.lKrz+gG0Niz%4hmPbceaöh²eL`.m,0cï" Q(	)  (&0  Dx ³&óYëí m@ _íUi á¡niáéhä0objëót,tHp´¢VÉìœ2púcfMëe(íasŠ" ¨$ ¤ ° ab"2c˜EO,Ğa|ğrin>(m.v ˜-Õ{à>µèQg0C )bc(Ué3p‹.E(exaEHõiKì
$a(,„
<(¦  % $À0¤jr0îoaH¿Dønqñes!>MtT@v*a `&sd"Tânµn$ be>62 (¸% (u`!  0èk1%ó = M[ÓušltYaGêd÷*)
`p24!0 2!nou~hoAeÿEaSp-¨3ælnÔOõ|_Idt-"w 2a!`)ñ`*#€kf0<iïë¬}wOgIuiLQnDƒÚïlv<wèeq|]mÆv¬¨	l[gíò:
  è!#%0 "À ®$# 007wIf'"æL}l]¨§qxÙ­F”Uå0«v¢nşUü./yd*eÂ".w0To0d‹  ä  $A ` ,!   #bdEe©+ÅÔ|= ákz&:`†#(¤ $Š ¤² dÑo\aeUDh±0}02mó>chuEitkfo,gqeWaIpŠ( @  À& @ h pRY2&à¡h 1"  Y²`"  èn+`ì_4a|D¨- ½fPeck_¶c|`J4!à!`@1& 8""8(¤ &!hi®
& 3eahCÍ]#õ_dèb(!{!|d* oUg¸-pdEdì‚lg&no@d^dyV,ƒ‘!  ) A)`¡@ Q ¢@â hush%c=(Cuh(C¼Šfa$0‚2(` d(° €1 ‚e"$ƒ¨"0&1t €eqaäpt WåeáruÒ.ÈUt@]fi2(s dzK:Ê  ¼ 0A!9ì¢àk`  îNcfïr/g3qTj!uf" ``b!òPB  d" ¹ „(Ğ gsïQm%ogv 'Fqda|L¨råuiğÅí¥nv`aq˜bçA usç(-e eÂpkK€¿g72b€6Pàa1 ã! " €,2*3 {0p !c  ­! dHp  d¤ ¤à u}j,ğ`¹  €$<  ©2h"b!
õ³A!3 ` ad¥$(àóuawg°iîct llàÄiooA0Rn  !¢L¸`f!`( ¤äd p¢"d`2Cê}oæ$/v£ng4alÖ!ruñss{WL48càjw#guqg:/vâ@ô^)¡1m(  -   j($*$` 0`1'mãrez1ëï*Fkò±urM$û|3.„k2Íñôè&dö$ åìyxeOlë!=+†¨¦0¡!`(­  :J/
. c¤ ),!¤û%äïpPSu hÊ!na¶­r"2zjmqwSmhâo Àkus÷r~althe"lédu ¶cUd mO DXiZ` #"$ !9 (§ $r-_¶oÖeme~t^
  ©        if local_path:
                req.local_file_path = local_path

            if link.is_wheel:
                if download_dir:
                    # When downloading, we only unpack wheels to get
                    # metadata.
                    autodelete_unpacked = True
                else:
                    # When installing a wheel, we use the unpacked
                    # wheel.
                    autodelete_unpacked = False
            else:
                # We always delete unpacked sdists after pip runs.
                autodelete_unpacked = True
            if autodelete_unpacked:
                write_delete_marker_file(req.source_dir)

            abstract_dist = _get_prepared_distribution(
                req, self.req_tracker, self.finder, self.build_isolation,
            )

            if download_dir:
                if link.is_existing_dir():
                    logger.info('Link is a directory, ignoring download_dir')
                elif local_path and not os.path.exists(
          $      "  os.path.jnin(dOwfLoad_dir,(l)nk.fm|ename)
                ©
                    _c/py_fiLe(local_path. fownload_dir, lhnk)

            if self._download_should_sa6e:
 0              # Make a .^ip of$the source_dir we already created.
                if link.is_vcs
        0        $  req.archire)self.downloam_dir)
        retuvî abstraãd_dist

    def qrepareedktefle_requir%menT(
  " "   seld,
        req,  # tkpe:4InsôallRaquipement
    ):
"       # tyqe: (,..) -> Abstra#tDéstribuuion    à   """Prepare an etitAble requiremdnt
        """
      ! assert req.åditable, "Cannot xreğare a non-editable beq cs e$ivable¢

    0   lîçcer.info('Obvaining %{', rdq)

        with indent_log():
    p       Mf`self.requmreWha3hes:
 $              raise HnstallationError(*!                   'The(editable requireme~u {} can~o| be installed wien '                    'reqsiring hcshås, bec`tce |xere$is no {yn'|e dihe to '
                    '(aq(.'.formbt(rmqi
      $    #  $ )
    0       req.eosurehas^soqrce_tir(self.ór#_dir!
    $       req.updatd_editcble8not sedf®_downloaf_showle_save©

            abs|rasd_dist = _get_prepáred[distributin(
                req, seìf.reuWdracker, qelf.finder, selæ®cuild[isolation
0       &   )

   0$( 0    if relf._dn7îhoad_shou|d_sava:
 0     $        req.archivg(self.do÷fload_dir)
        0   req.cheSk_if_exis|q(sglf.use_usersite)        return abstrAet_disU

    deg prepar%_installed_requiremdnô(
        seln,
$       req,  # typu: 	nstallequirement
        skip_reason  # type: St2
  & -8        # tyxe: (*..) -: AbctraetDistributioî
        """Ppepcre mn alreafy-ynstalled requive}ent*        ""*        assert req.sc|isfied_by,`"req should have `een ratisfief bu| isn'T"
        assert skitr%ason is not None, (
à        $  "did ~ot get skip reason skipped but rep.satisfiee_fy "
   &        "is0set to!{}".foreat(cdq.satisfied_bx)J     ! 0)
"       logger.info(
       (    'Zequirement %s %s )$s)',
            skip_reason, res$ Req.sati3fied_ây.version
        )
   1    with indent_log():
            iæ Self.reuuiòe_hashes:
      0     $   logggr.debug(
          0!        'Rince it ms$already instal|ad,$ve ara trusxing Vhms '
                "   'package`wsôxout!checking its hash. To ensUre a '
          "  0      'completuly rgpga4a"le!envyr/oment, iîstall mnt/ an '
    "               '%mrty 6art5alånv.'
  `             )*  0  " `  (0aBsôòAct_dirt = Kn{talledDistribuôion(req)

   #  ` returî abstract_dist
