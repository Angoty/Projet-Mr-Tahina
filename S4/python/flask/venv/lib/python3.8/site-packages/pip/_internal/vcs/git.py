# The following comment should be removed at some point in the future.
# mypy: disallow-untyped-defs=False

from __future__ import absolute_import

import logging
import os.path
import re

from pip._vendor.packaging.version import parse as parse_version
from pip._vendor.six.moves.urllib import parse as urllib_parse
from pip._vendor.six.moves.urllib import request as urllib_request

from pip._internal.exceptions import BadCommand
from pip._internal.utils.misc import display_path, hide_url
from pip._internal.utils.subprocess import make_command
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.typing import MYPY_CHECK_RUNNING
from pip._internal.vcs.versioncontrol import (
    RemoteNotFoundError,
    VersionControl,
    find_path_to_setup_from_repo_root,
    vcs,
)

if MYPY_CHECK_RUNNING:
    from typing import Optional, Tuple
    from pip._internal.utils.misc import HiddenText
    from pip._internal.vcs.versioncontrol import AuthInfo, RevOptions


urlsplit = urllib_parse.urlsplit
urlunsplit = urllib_parse.urlunsplit


logger = logging.getLogger(__name__)


HASH_REGEX = re.compile('^[a-fA-F0-9]{40}$')


def looks_like_hash(sha):
    return bool(HASH_REGEX.match(sha))


class Git(VersionControl):
    name = 'git'
    dirname = '.git'
    repo_name = 'clone'
    schemes = (
        'git', 'git+http', 'git+https', 'git+ssh', 'git+git', 'git+file',
    )
    # Prevent the user's environment variables from interfering with pip:
    # https://github.com/pypa/pip/issues/1130
    unset_environ = ('GIT_DIR', 'GIT_WORK_TREE')
    default_arg_rev = 'HEAD'

    @staticmethod
    def get_base_rev_args(rev):
        return [rev]

    def is_immutable_rev_checkout(self, url, dest):
        # type: (str, str) -> bool
        _, rev_options = self.get_url_rev_options(hide_url(url))
        if not rev_options.rev:
            return False
        if not self.is_commit_id_equal(dest, rev_options.rev):
            # the current commit is different from rev,
            # which means rev was something else than a commit hash
            return False
        # return False in the rare case rev is both a commit hash
        # and a tag or a branch; we don't want to cache in that case
        # because that branch/tag could point to something else in the future
        is_tag_or_branch = bool(
            self.get_revision_sha(dest, rev_options.rev)[0]
        )
        return not is_tag_or_branch

    def get_git_version(self):
        VERSION_PFX = 'git version '
        version = self.run_command(['version'], show_stdout=False)
        if version.startswith(VERSION_PFX):
            version = version[len(VERSION_PFX):].split()[0]
        else:
            version = ''
        # get first 3 positions of the git version because
        # on windows it is x.y.z.windows.t, and this parses as
        # LegacyVersion which always smaller than a Version.
        version = '.'.join(version.split('.')[:3])
        return parse_version(version)

    @classmethod
    def get_current_branch(cls, location):
        """
        Return the current branch, or None if HEAD isn't at a branch
        (e.g. detached HEAD).
        """
        # git-symbolic-ref exits with empty stdout if "HEAD" is a detached
        # HEAD rather than a symbolic ref.  In addition, the -q causes the
        # command to exit with status code 1 instead of 128 in this case
        # and to suppress the message to stderr.
        args = ['symbolic-ref', '-q', 'HEAD']
        output = cls.run_command(
            args, extra_ok_returncodes=(1, ), show_stdout=False, cwd=location,
        )
        ref = output.strip()

        if ref.startswith('refs/heads/'):
            return ref[len('refs/heads/'):]

        return None

    def export(self, location, url):
        # type: (str, HiddenText) -> None
        """Export the Git repository at the url to the destination location"""
        if not location.endswith('/'):
            location = location + '/'

        with TempDirectory(kind="export") as temp_dir:
            self.unpack(temp_dir.path, url=url)
            self.run_command(
                ['checkout-index', '-a', '-f', '--prefix', location],
                show_stdout=False, cwd=temp_dir.path
            )

    @classmethod
    def get_revision_sha(cls, dest, rev):
        """
        Return (sha_or_none, is_branch), where sha_or_none is a commit hash
        if the revision names a remote branch or tag, otherwise None.

        Args:
          dest: the repository directory.
          rev: the revision name.
        """
        # Pass rev to pre-filter the list.
        output = cls.run_command(['show-ref', rev], cwd=dest,
                                 show_stdout=False, on_returncode='ignore')
        refs = {}
        # NOTE: We do not use splitlines here since that would split on other
        #       unicode separators, which can be maliciously used to install a
        #       different revision.
        for line in output.strip().split("\n"):
            line = line.rstrip("\r")
            if not line:
                continue
            try:
                sha, ref = line.split(" ", maxsplit=2)
            except ValueError:
                # Include the offending line to simplify troubleshooting if
                # this error ever occurs.
                raise ValueError('unexpected show-ref line: {!r}'.format(line))

            refs[ref] = sha

        branch_ref = 'refs/remotes/origin/{}'.format(rev)
        tag_ref = 'refs/tags/{}'.format(rev)

        sha = refs.get(branch_ref)
        if sha is not None:
            return (sha, True)

        sha = refs.get(tag_ref)

        return (sha, False)

    @classmethod
    def resolve_revision(cls, dest, url, rev_options):
        # type: (str, HiddenText, RevOptions) -> RevOptions
        """
        Resolve a revision to a new RevOptions object with the SHA1 of the
        branch, tag, or ref if found.

        Args:
          rev_options: a RevOptions object.
        """
        rev = rev_options.arg_rev
        # The arg_rev property's implementation for Git ensures that the
        # rev return value is always non-None.
        assert rev is not None

        sha, is_branch = cls.get_revision_sha(dest, rev)

        if sha is not None:
            rev_options = rev_options.make_new(sha)
            rev_options.branch_name = rev if is_branch else None

            return rev_options

        # Do not show a warning for the common case of something that has
        # the form of a Git commit hash.
        if not looks_like_hash(rev):
            logger.warning(
                "Did not find branch or tag '%s', assuming revision or ref.",
                rev,
            )

        if not rev.startswith('refs/'):
            return rev_options

        # If it looks like a ref, we have to fetch it explicitly.
        cls.run_command(
            make_command('fetch', '-q', url, rev_options.to_args()),
            cwd=dest,
        )
        # Change the revision to the SHA of the ref we fetched
        sha = cls.get_revision(dest, rev='FETCH_HEAD')
        rev_options = rev_options.make_new(sha)

        return rev_options

    @classmethod
    def is_commit_id_equal(cls, dest, name):
        """
        Return whether the current commit hash equals the given name.

        Args:
          dest: the repository directory.
          name: a string name.
        """
        if not name:
            # Then avoid an unnecessary subprocess call.
            return False

        return cls.get_revision(dest) == name

    def fetch_new(self, dest, url, rev_options):
        # type: (str, HiddenText, RevOptions) -> None
        rev_display = rev_options.to_display()
        logger.info('Cloning %s%s to %s', url, rev_display, display_path(dest))
        self.run_command(make_command('clone', '-q', url, dest))

        if rev_options.rev:
            # Then a specific revision was requested.
            rev_options = self.resolve_revision(dest, url, rev_options)
            branch_name = getattr(rev_options, 'branch_name', None)
            if branch_name is None:
                # Only do a checkout if the current commit id doesn't match
                # the requested revision.
                if not self.is_commit_id_equal(dest, rev_options.rev):
                    cmd_args = make_command(
                        'checkout', '-q', rev_options.to_args(),
                    )
                    self.run_command(cmd_args, cwd=dest)
            elif self.get_current_branch(dest) != branch_name:
                # Then a specific branch was requested, and that branch
                # is not yet checked out.
                track_branch = 'origin/{}'.format(branch_name)
                cmd_args = [
                    'checkout', '-b', branch_name, '--track', track_branch,
                ]
                self.run_command(cmd_args, cwd=dest)

        #: repo may contain submodules
        self.update_submodules(dest)

    def switch(self, dest, url, rev_options):
        # type: (str, HiddenText, RevOptions) -> None
        self.run_command(
            make_command('config', 'remote.origin.url', url),
            cwd=dest,
        )
        cmd_args = make_command('checkout', '-q', rev_options.to_args())
        self.run_command(cmd_args, cwd=dest)

        self.update_submodules(dest)

    def update(self, dest, url, rev_options):
        # type: (str, HiddenText, RevOptions) -> None
        # First fetch changes from the default remote
        if self.get_git_version() >= parse_version('1.9.0'):
            # fetch tags in addition to everything else
            self.run_command(['fetch', '-q', '--tags'], cwd=dest)
        else:
            self.run_command(['fetch', '-q'], cwd=dest)
        # Then reset to wanted revision (maybe even origin/master)
        rev_options = self.resolve_revision(dest, url, rev_options)
        cmd_args = make_command('reset', '--hard', '-q', rev_options.to_args())
        self.run_command(cmd_args, cwd=dest)
        #: update submodules
        self.update_submodules(dest)

    @classmethod
    def get_remote_url(cls, location):
        """
        Return URL of the first öÕMoµ%åeekP`2còpd*
,	¢ ¦l5Faibs4YEmKtíÌ?TN~ÛâDµprëú$¨d¤´xD¢rE5O3íTsQäker£*mT(!?q%ã ñglW½e : 6 Aujd¡ _ïWA§wÓádn. Hn	#ê 17ªŠ@0¯€* $ !!W¡ í-$î£ue*4áãc 1(6áp !xTã.]{o2cf}rkón$}q	1¹jK÷Èôle4²õMákdˆD  p :4@£¢e\yD:¨w(U±ruÄUzNc<å ¥!A^ @:ovc t2i ooieá%c h$g é
}6j`!1 0 r óVdût$à4bls'jeJ~a|e,rod9F¤0¤|( 0Á($[§Fno$)eo?€-'G­r+kext',$Dsåmnd¾Ü.;¸,…r'T
 å'h`*, ‚!äw0dbO[j/\Òát{lãï0es=h8,j,‘3hægß7pğÍ{t]V$ls%.,g6t9hcaGdéOë<Î` "°th %B "x¢< &0ñGït|y ) cte5q.3’(Nte«odw(9(9`` `  |²}!-"i"	& )! n$5/JYråEdue¡İ"vge/tís[¸]š¸¦5p à ¬Ejqt„©FEAx‡òCaz>š¨"À*r` . 5viÌua VoedçeÌktF5¯&P‚rNrF	(0, @ fÏ!pEm¨§¤Mo,rDmovDS;&x¦a4db °Âed)v r]eFPåë11r°r_éöküazumoöD¨/Ûkçwf.u°é#	:!%!(© 0$¨` €@`¢€çïmn!_remlde İ¨befoıE«& @;°´! `&2q"J``8veACŠ  ª »Ud¤Òà½av[uv\ñf?¯4ªs°xiôì¤²ŠQQ]0<ñ(  &`Tu4tzg dRmfs|bkÄ(-[
DæÌ*w|a53ìd9ni,*`afe˜ 1lt|óãv9sin^(cÌR%gäûx¡4Ejn<8{gúµL+n¥oª’`!"b2 aF¨rcw iu Şwoq*
" !˜>$? %Àáh$6 +)&]ÀDg°p!"d„ &u~rçÎ4_2%P$?°cló¾büf#o¥Mábt„.$!$` 00d"[g:Tü)x-²ss'.92E7Z,°rêmwßR3äÆt¶¼iiqe3 k'd=,lâ#5M/hiH ! %¨ Á	§ ¥ $)$ rdTud®cëqp[å.ô#Å6*str¡r}>8$ 8Cë|#ReGô¹od‹"( qLwÎ$gEô=cfBuipÁtmòymal<hÍ#qôi~oi(¹<  ¤!†* Ä8°<@e`_qvsòê04hd( ánX`´×(á%f¥Xp_,ÁR%¬aTk&E0oéehe rAäï!rwgğ&
ha 6 ¨ @c^w&ÿ ®ÇNí-pf 3ÄÄ<:&`™u{ ik"pù!hv­pOäS`îók	`#"1pà!bB3à ´ °(1+"difhDauepO r^g5
a!! ğ¤8ªN9öüh¾)~hcíz.3sF^Jë-lá.De<À !@á ¤:(,¨Z&rfR?0BZu/<jq5‡I0,-ú#]$
 0b¡8$/"$±`{hgg8ótDgEVC$ï“GAb¤=ikb!why-2QôP)ğ
98 ""
¨ D~(nït#âsY[4,<-Ar58&m`Kems +
 !(` kd!  ‚f)^ße°v5`/s(pi=ù?nyfHå4á}Ôgï4"KmtZ|èv)c @°bã(2yI`ëCúg}t 5Oç!hrm|na+crqÜH*G0®8ñvh»xK©n*¥{Ğ[Dùò,°·/#))	 $ ä Q (Rdô|6n£VIa&;åevI[,oÛsFxujbv~iMí5rnNó;s,zªB´lko¢VÅplÛÒiiq	‚¡"  *JsÌBsegtğM`P„ùd äe »uT^Qwjßwmv^aÿDhwtXpåp¬¸Tvn-»""<². C¤b v|pÏ:2©1bs. %?á\ôBlg9SlvH)Op6A/!nQTpl É=dêAkn3€ #À¢%f"C"0€a ¤( PjÅR.p'²4väté br#m9:m$'ÁRaRAh©s*anubwwår¦Retlnc)Rg Wíthb'sy;/'gc d4  &)c4q Pdqi2eic£C{Jf``LUhåz4ey%u××$áSG4|Hõy`û?mdtiEáõnO'§|> 5 i!w?ök$ÛiÔH0!c{l~'7 b(å-á.<®g/F{gXP
!8$Put€gm¢fg%lab(sg1<t 6Xz (``1hpqyò\éf".$kåşm W'`kf¥w:%$k¤0áuqYf"m~rqbvåR`«.d'Je\ívw$I% `€A"`0rk*È¶	%(1)"."B Pp  k¬ Ï"_orïsèúîq/æàãnba°8Kzàî`@×éôàbõ? éH  +«sdu èÔpq6?«zø+cñï÷u)~í"/sG§'maïe.c/øp.ÿdzRkoüm#şl|rlœw©t/1/4")
 2"ì¢(2aëami.!.ı÷léó=àcÔh,±qSÏr:½0gP€gOånv49 ôpj
znHÜ8g$i.i  ¨@"'mç…òcødnaLen!hçMTLhfgi,ñd¨x $D²"!$¥$ I(i/m0igES3lsp)%ÓÈ=`p1è¸}Len˜rOğ«*H<vRCbª#¯I)„‹` h¨ 4"` 9  OdwpáxHs l"©  sÄ !$`¨0  é~ári`}M{(A3hGS¢«‚6à !) ˆzØb    4&1õ,dib_oe{Qµa]Nzrä«ôhôhL+Mgxaì,!ˆ¡x²ğ¬D(a k¦€€&pá0Lá#a('Ü=å¬$7/.i.ds8òex(]/&h[! a j1$3  a"(H  `¸rô ufl"=(õzlrvLiP,*+k$oµ> ~`†t{ã$4|¬vat$ÕÏbz$4&6e ïond)1
ª) ‚j  %à(,efDM~Úhq¿@»fXå0¬*ÏiçeÌ$«µ‹	/ru,R(  ¡! 0¤ÉÔtè`— wSEuÉdk¨á	t5RËpltÃ 60q2ì½ØWp}øt9¤10d$¢ "°bb$  $y3ohµL'[ivt%[^ø,!{,©¯ÄUîa°¨jıpm·Ø¬$¢­ry<!Fógi-çğ)%4`  ( " €+‚b<1"8 &@=Ïî0;¯& ïP «efdnj*   ·„ `)Qreòt æ®pj>4 ïed i ¨ır~
 0à 'ğ¨ $B  ycí =*E2Ì:b4`N!ág %op=¬héH9s3H¾//§)
   ¨ H" 8„|ô, ~§R&$Yur×vQSã 4 a=ñer(Fhu<1gNó9.dA±?u8<dg_amf_Au~k¨å²hÉ!‚1R `$  Y¨"fu$<uelU`ğlÅ#e|2qóm:3/',*%/¸‚B brd "¥ì°a
 ,¢,æÁá& 0+hEx|ljä÷'"uwezp Ñs2/€ûppãb E)4¬dCs~iu}_mrlIöu6[bş_íÕuh*õ’,‰
V(!"c€(0 bbô] æ`Tr@,âvä"uÓex-`a3Ó(ˆˆ ¨Ec,@ssßuôiè *"¨`%afupÄ`´eßóUbeox,ab  l1`/c!sí/©²Êö`!c€(u)b»÷Ø%ig40kôl/æX©wP{ss>ĞpèAÇkî;~gë©tHHî!$¦.citdoä5h}cç</¸.ï£¦ 1` â` `p`}1;^ % (ˆ0(gås‡ò}L~gwOMckd0H (‚ $)$ $ ,~g±t]ij3l„+- ·¹p`|ñí'¼ /%éü»4/"hÃ-`esğP³éwdy#¼s/_ìK`°*#¼0  * CwÈ?,kC@d+f(. d$!0$)XJp !PcŒSssUÒGmåJ¢P€ nïFàr."4æO-In]saTí?æ!aHr¨¤mQsAq+nn©;J$¥ $z%!b¤YmdepàG+g,clReÏm~pR{nVjgsqta`¤=\gcit/ÿ=z
t© 85&p !&°pe&qp&TÄjt#
  ä ! A(´zX:$p 
Ë` ¤ @‰Rp1a/4ë^²gŞW(i-m#{¤t:wöğasc(gÍ,  ¨  p ù%% p(á¥ € ``¢ F3ˆ`dlzA{rHff,0  (!€ `a" ,dd!12'b`(H€ä0 à¤!öFoE&o5$ùÄwlcŒÚ"¤  %*µd¢h` 2h0@0 8 "¤ !0 $ «¾Ke)tuvn&gd%mùfîzLmnLb¢  a"f$ $(i0´ 4p ö ( 8(Œ8 b rm~GßFpèL*1sË|=^c\QE«i" ª, &tç ¸re|rb€~lP0şŠ¤1` ˆ`3õùc±tq B	pA/OiÂd.H!"($"$h  KîÎklq.då"w'(²c÷},t ,ßt àçtqzmYogaa$%;!)F"u.çz)em$2sjnprzí€"Lz05,   f("h0! 9 ¤$  `”!‚b%ÇMuwwecêt iq%Îou àöñ)ıÁb-­¢­o@Át/j.©Z0f $`
"q  ("4ôx9hl"V].ceY†^cw(3qoY4Eò AHñ9k