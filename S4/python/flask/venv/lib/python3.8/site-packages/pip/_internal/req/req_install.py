# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

from __future__ import absolute_import

import logging
import os
import shutil
import sys
import zipfile

from pip._vendor import pkg_resources, six
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version
from pip._vendor.pep517.wrappers import Pep517HookCaller

from pip._internal import pep425tags
from pip._internal.build_env import NoOpBuildEnvironment
from pip._internal.exceptions import InstallationError
from pip._internal.locations import get_scheme
from pip._internal.models.link import Link
from pip._internal.operations.build.metadata import generate_metadata
from pip._internal.operations.build.metadata_legacy import \
    generate_metadata as generate_metadata_legacy
from pip._internal.operations.install.editable_legacy import \
    install_editable as install_editable_legacy
from pip._internal.operations.install.legacy import install as install_legacy
from pip._internal.operations.install.wheel import install_wheel
from pip._internal.pyproject import load_pyproject_toml, make_pyproject_path
from pip._internal.req.req_uninstall import UninstallPathSet
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.hashes import Hashes
from pip._internal.utils.logging import indent_log
from pip._internal.utils.marker_files import (
    PIP_DELETE_MARKER_FILENAME,
    has_delete_marker_file,
    write_delete_marker_file,
)
from pip._internal.utils.misc import (
    ask_path_exists,
    backup_dir,
    display_path,
    dist_in_site_packages,
    dist_in_usersite,
    get_installed_version,
    hide_url,
    redact_auth_from_url,
    rmtree,
)
from pip._internal.utils.packaging import get_metadata
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.typing import MYPY_CHECK_RUNNING
from pip._internal.utils.virtualenv import running_under_virtualenv
from pip._internal.vcs import vcs

if MYPY_CHECK_RUNNING:
    from typing import (
        Any, Dict, Iterable, List, Optional, Sequence, Union,
    )
    from pip._internal.build_env import BuildEnvironment
    from pip._internal.cache import WheelCache
    from pip._internal.index.package_finder import PackageFinder
    from pip._vendor.pkg_resources import Distribution
    from pip._vendor.packaging.specifiers import SpecifierSet
    from pip._vendor.packaging.markers import Marker


logger = logging.getLogger(__name__)


def _get_dist(metadata_directory):
    # type: (str) -> Distribution
    """Return a pkg_resources.Distribution for the provided
    metadata directory.
    """
    dist_dir = metadata_directory.rstrip(os.sep)

    # Determine the correct Distribution object type.
    if dist_dir.endswith(".egg-info"):
        dist_cls = pkg_resources.Distribution
    else:
        assert dist_dir.endswith(".dist-info")
        dist_cls = pkg_resources.DistInfoDistribution

    # Build a PathMetadata object, from path to metadata. :wink:
    base_dir, dist_dir_name = os.path.split(dist_dir)
    dist_name = os.path.splitext(dist_dir_name)[0]
    metadata = pkg_resources.PathMetadata(base_dir, dist_dir)

    return dist_cls(
        base_dir,
        project_name=dist_name,
        metadata=metadata,
    )


class InstallRequirement(object):
    """
    Represents something that may be installed later on, may have information
    about where to fetch the relevant requirement and also contains logic for
    installing the said requirement.
    """

    def __init__(
        self,
        req,  # type: Optional[Requirement]
        comes_from,  # type: Optional[Union[str, InstallRequirement]]
        source_dir=None,  # type: Optional[str]
        editable=False,  # type: bool
        link=None,  # type: Optional[Link]
        markers=None,  # type: Optional[Marker]
        use_pep517=None,  # type: Optional[bool]
        isolated=False,  # type: bool
        options=None,  # type: Optional[Dict[str, Any]]
        wheel_cache=None,  # type: Optional[WheelCache]
        constraint=False,  # type: bool
        extras=()  # type: Iterable[str]
    ):
        # type: (...) -> None
        assert req is None or isinstance(req, Requirement), req
        self.req = req
        self.comes_from = comes_from
        self.constraint = constraint
        if source_dir is None:
            self.source_dir = None  # type: Optional[str]
        else:
            self.source_dir = os.path.normpath(os.path.abspath(source_dir))
        self.editable = editable

        self._wheel_cache = wheel_cache
        if link is None and req and req.url:
            # PEP 508 URL requirement
            link = Link(req.url)
        self.link = self.original_link = link
        # Path to any downloaded or already-existing package.
        self.local_file_path = None  # type: Optional[str]
        if self.link and self.link.is_file:
            self.local_file_path = self.link.file_path

        if extras:
            self.extras = extras
        elif req:
            self.extras = {
                pkg_resources.safe_extra(extra) for extra in req.extras
            }
        else:
            self.extras = set()
        if markers is None and req:
            markers = req.marker
        self.markers = markers

        # This holds the pkg_resources.Distribution object if this requirement
        # is already available:
        self.satisfied_by = None  # type: Optional[Distribution]
        # Whether the installation process should try to uninstall an existing
        # distribution before installing this requirement.
        self.should_reinstall = False
        # Temporary build location
        self._temp_build_dir = None  # type: Optional[TempDirectory]
        # Set to True after successful installation
        self.install_succeeded = None  # type: Optional[bool]
        self.options = options if options else {}
        # Set to True after successful preparation of this requirement
        self.prepared = False
        self.is_direct = False

        self.isolated = isolated
        self.build_env = NoOpBuildEnvironment()  # type: BuildEnvironment

        # For PEP 517, the directory where we request the project metadata
        # gets stored. We need this to pass to build_wheel, so the backend
        # can ensure that the wheel matches the metadata (see the PEP for
        # details).
        self.metadata_directory = None  # type: Optional[str]

        # The static build requirements (from pyproject.toml)
        self.pyproject_requires = None  # type: Optional[List[str]]

        # Build requirements that we will check are available
        self.requirements_to_check = []  # type: List[str]

        # The PEP 517 backend we should use to build the project
        self.pep517_backend = None  # type: Optional[Pep517HookCaller]

        # Are we using PEP 517 for this requirement?
        # After pyproject.toml has been loaded, the only valid values are True
        # and False. Before loading, None is valid (meaning "use the default").
        # Setting an explicit value before loading pyproject.toml is supported,
        # but after loading this flag should be treated as read only.
        self.use_pep517 = use_pep517

    def __str__(self):
        # type: () -> str
        if self.req:
            s = str(self.req)
            if self.link:
                s += ' from %s' % redact_auth_from_url(self.link.url)
        elif self.link:
            s = redact_auth_from_url(self.link.url)
        else:
            s = '<InstallRequirement>'
        if self.satisfied_by is not None:
            s += ' in %s' % display_path(self.satisfied_by.location)
        if self.comes_from:
            if isinstance(self.comes_from, six.string_types):
                comes_from = self.comes_from  # type: Optional[str]
            else:
                comes_from = self.comes_from.from_path()
            if comes_from:
                s += ' (from %s)' % comes_from
        return s

    def __repr__(self):
        # type: () -> str
        return '<%s object: %s editable=%r>' % (
            self.__class__.__name__, str(self), self.editable)

    def format_debug(self):
        # type: () -> str
        """An un-tested helper for getting state, for debugging.
        """
        attributes = vars(self)
        names = sorted(attributes)

        state = (
            "{}={!r}".format(attr, attributes[attr]) for attr in sorted(names)
        )
        return '<{name} object: {{{state}}}>'.format(
            name=self.__class__.__name__,
            state=", ".join(state),
        )

    def populate_link(self, finder, upgrade, require_hashes):
        # type: (PackageFinder, bool, bool) -> None
        """Ensure that if a link can be found for this, that it is found.

        Note that self.link may still be None - if Upgrade is False and the
        requirement is already installed.

        If require_hashes is True, don't use the wheel cache, because cached
        wheels, always built locally, have different hashes than the files
        downloaded from the index server and thus throw false hash mismatches.
        Furthermore, cached wheels at present have undeterministic contents due
        to file modification times.
        """
        if self.link is None:
            self.link = finder.find_requirement(self, upgrade)
        if self._wheel_cache is not None and not require_hashes:
            old_link = self.link
            supported_tags = pep425tags.get_supported()
            self.link = self._wheel_cache.get(
                link=self.link,
                package_name=self.name,
                supported_tags=supported_tags,
            )
            if old_link != self.link:
                logger.debug('Using cached wheel link: %s', self.link)

    # Things that are valid for all kinds of requirements?
    @property
    def name(self):
        # type: () -> Optional[str]
        if self.req is None:
            return None
        return six.ensure_str(pkg_resources.safe_name(self.req.name))

    @property
    def specifier(self):
        # type: () -> SpecifierSet
        return self.req.specifier

    @property
    def is_pinned(self):
        # type: () -> bool
        """Return whether I am pinned to an exact version.

        For example, some-package==1.2 is pinned; some-package>1.2 is not.
        """
        specifiers = self.specifier
        return (len(specifiers) == 1 and
                next(iter(specifiers)).operator in {'==', '==='})

    @property
    def installed_version(self):
        # type: () -> Optional[str]
        return get_installed_version(self.name)

    def match_markers(self, extras_requested=None):
        # type: (Optional[Iterable[str]]) -> bool
        if not extras_requested:
            # Provide an extra to safely evaluate the markers
            # without matching any extra
            extras_requested = ('',)
        if self.markers is not None:
            return any(
                self.markers.evaluate({'extra': extra})
                for extra in extras_requested)
        else:
            return True

    @property
    def has_hash_options(self):
        # type: () -> bool
        """Return whether any known-good hashes are specified as options.

        These activate --require-hashes mode; hashes specified as part of a
        URL do not.

        """
        return bool(self.options.get('hashes', {}))

    def hashes(self, trust_internet=True):
        # type: (bool) -> Hashes
        """Return a hash-comparer that considers my option- and URL-based
        hashes to be known-good.

        Hashes in URLs--ones embedded in the requirements file, not ones
        downloaded from an index server--are almost peers with ones from
        flags. They satisfy --require-hashes (whether it was implicitly or
        explicitly activated) but do not activate it. md5 and sha224 are not
        allowed in flags, which should nudge people toward good algos. We
        always OR all hashes together, even ones from URLs.

        :param trust_internet: Whether to trust URL-based (#md5=...) hashes
            downloaded from the internet, as by populate_link()

        """
        good_hashes = self.options.get('hashes', {}).copy()
        link = self.link if trust_internet else self.original_link
        if link and link.hash:
            good_hashes.setdefault(link.hash_name, []).append(link.hash)
        return Hashes(good_hashes)

    def from_path(self):
        # type: () -> Optional[str]
        """Format a nice indicator to show where this "comes from"
        """
        if self.req is None:
            return None
        s = str(self.req)
        if self.comes_from:
            if isinstance(self.comes_from, six.string_types):
                comes_from = self.comes_from
            else:
                comes_from = self.comes_from.from_path()
            if comes_from:
                s += '->' + comes_from
        return s

    def ensure_build_location(self, build_dir):
        # type: (str) -> str
        assert build_dir is not None
        if self._temp_build_dir is not None:
            assert self._temp_build_dir.path
            return self._temp_build_dir.path
        if self.req is None:
            # Some systems have /tmp as a symlink which confuses custom
            # builds (such as numpy). Thus, we ensure that the real path
            # is returned.
            self._temp_build_dir = TempDirectory(kind="req-build")

            return self._temp_build_dir.path
        if self.editable:
            name = self.name.lower()
        else:
            name = self.name
        # FIXME: Is there a better place to create the build_dir? (hg and bzr
        # need this)
        if not os.path.exists(build_dir):
            logger.debug('Creating directory %s', build_dir)
            os.makedirs(build_dir)
            write_delete_marker_file(build_dir)
        return os.path.join(build_dir, name)

    def _set_requirement(self):
        # type: () -> None
        """Set requirement after generating metadata.
        """
        assert self.req is None
        assert self.metadata is not None
        assert self.source_dir is not None

        # Construct a Requirement object from the generated metadata
        if isinstance(parse_version(self.metadata["Version"]), Version):
            op = "=="
        else:
            op = "==="

        self.req = Requirement(
            "".join([
                self.metadata["Name"],
                op,
                self.metadata["Version"],
            ])
        )

    def warn_on_mismatching_name(self):
        # type: () -> None
        metadata_name = canonicalize_name(self.metadata["Name"])
        if canonicalize_name(self.req.name) == metadata_name:
            # Everything is fine.
            return

        # If we're here, there's a mismatch. Log a warning about it.
        logger.warning(
            'Generating metadata for package %s '
            'produced metadata for project name %s. Fix your '
            '#egg=%s fragments.',
            self.name, metadata_name, self.name
        )
        self.req = Requirement(metadata_name)

    def remove_temporary_source(self):
        # type: () -> None
        """Remove the source files from this requirement, if they are marked
        for deletion"""
        if self.source_dir and has_delete_marker_file(self.source_dir):
            logger.debug('Removing source in %s', self.source_dir)
            rmtree(self.source_dir)
        self.source_dir = None
        if self._temp_build_dir:
            self._temp_build_dir.cleanup()
            self._temp_build_dir = None
        self.build_env.cleanup()

    def check_if_exists(self, use_user_site):
        # type: (bool) -> None
        """Find an installed distribution that satisfies or conflicts
        with this requirement, and set self.satisfied_by or
        self.should_reinstall appropriately.
        """
        if self.req is None:
            return
        # get_distribution() will resolve the entire list of requirements
        # anyway, and we've already determined that we need the requirement
        # in question, so strip the marker so that we don't try to
        # evaluate it.
        no_marker = Requirement(str(self.req))
        no_marker.marker = None
        try:
            self.satisfied_by = pkg_resources.get_distribution(str(no_marker))
        except pkg_resources.DistributionNotFound:
            return
        except pkg_resources.VersionConflict:
            existing_dist = pkg_resources.get_distribution(
                self.req.name
            )
            if use_user_site:
                if dist_in_usersite(existing_dist):
                    self.should_reinstall = True
                elif (running_under_virtualenv() and
                        dist_in_site_packages(existing_dist)):
                    raise InstallationError(
                        "Will not install to the user site because it will "
                        "lack sys.path precedence to %s in %s" %
                        (existing_dist.project_name, existing_dist.location)
                    )
            else:
                self.should_reinstall = True
        else:
            if self.editable and self.satisfied_by:
                self.should_reinstall = True
                # when installing editables, nothing pre-existing should ever
                # satisfy
                self.satisfied_by = None

    # Things valid for wheels
    @property
    def is_wheel(self):
        # type: () -> bool
        if not self.link:
            return False
        return self.link.is_wheel

    # Things valid for sdists
    @property
    def unpacked_source_directory(self):
        # type: () -> str
        return os.path.join(
            self.source_dir,
            self.link and self.link.subdirectory_fragment or '')

    @property
    def setup_py_path(self):
        # type: () -> str
        assert self.source_dir, "No source dir for %s" % self
        setup_py = os.path.join(self.unpacked_source_directory, 'setup.py')

        # Python2 __file__ should not be unicode
        if six.PY2 and isinstance(setup_py, six.text_type):
            setup_py = setup_py.encode(sys.getfilesystemencoding())

        return setup_py

    @property
    def pyproject_toml_path(self):
        # type: () -> str
        assert self.source_dir, "No source dir for %s" % self
        return make_pyproject_path(self.unpacked_source_directory)

    def load_pyproject_toml(self):
        # type: () -> None
        """Load the pyproject.toml file.

        After calling this routine, all of the attributes related to PEP 517
        processing for this requirement have been set. In particular, the
        use_pep517 attribute can be used to determine whether we should
        follow the PEP 517 or legacy (setup.py) code path.
        """
        pyproject_toml_data = load_pyproject_toml(
            self.use_pep517,
            self.pyproject_toml_path,
            self.setup_py_path,
            str(self)
        )

        if pyproject_toml_data is None:
            self.use_pep517 = False
            return

        self.use_pep517 = True
        requires, backend, check, backend_path = pyproject_toml_data
        self.requirements_to_check = check
        self.pyproject_requires = requires
        self.pep517_backend = Pep517HookCaller(
            self.unpacked_source_directory, backend, backend_path=backend_path,
        )

    def _generate_metadata(self):
        # type: () -> str
        """Invokes metadata generator functions, with the required arguments.
        """
        if not self.use_pep517:
            assert self.unpacked_source_directory

            return generate_metadata_legacy(
                build_env=self.build_env,
                setup_py_path=self.setup_py_path,
                source_dir=self.unpacked_source_directory,
                editable=self.editable,
                isolated=self.isolated,
                details=self.name or "from {}".format(self.link)
            )

        assert self.pep517_backend is not None

        return generate_metadata(
            build_env=self.build_env,
            backend=self.pep517_backend,
        )

    def prepare_metadata(self):
        # type: () -> None
        """Ensure that project metadata is available.

        Under PEP 517, call the backend hook to prepare the metadata.
        Under legacy processing, call setup.py egg-info.
        """
        assert self.source_dir

        with indent_log():
            self.metadata_directory = self._generate_metadata()

        # Act on the newly generated metadata, based on the name and version.
        if not self.name:
            self._set_requirement()
        else:
            self.warn_on_mismatching_name()

        self.assert_source_matches_version()

    @property
    def metadata(self):
        # type: () -> Any
        if not hasattr(self, '_metadata'):
            self._metadata = get_metadata(self.get_dist())

        return self._metadata

    def get_dist(self):
        # type: () -> Distribution
        return _get_dist(self.metadata_directory)

    def assert_source_matches_version(self):
        # type: () -> Non-(â¸$" "% ©cZdf} s$‰&.wŸurC#ït+rj ° $"!¡>"óiì7}¬²ele?dÍ0ãdaumJwj&rbavn1]‰* 4 %ò¥akU"Óü,vriq.s0Lêiri%v4ÑN¦áDq@wx$>`
-th™~c%,$krWñ4{ñMZfğs8Ë#`"à"y 4!&kn'Emaq.7!`nD%D(;€, rp2(´``" *  ç”kqu%[Ved˜ 2>êuô4im{t`Læhfg°~utsoÔ‚qg,šGè( € ¡ñ  ¡,a"0âetwlÚép " &¸!!h 2 ©`6Erciï+l
h +æ ¥<2Œ +šbéq   ä"íds%új Ñ@ ( ! & !l}'ocìõağİ%>f   5% ‚x`ÁT£ †
7So}wc}`kj(…s2(‘s0öi2Umí	´t$ wèm"úqeüiwf}‡s0coaT1ukádTfG{'D
`°`¨!P   `0-:ª,Lcóp|`iUPG6(j2ilh&k=QrkeKåhw-J. *  †15$F`µ041*vGÒqa÷ŒC"0008 x¢( €  "uUtob3( °X1 
!²)	!@0dRßçb!vx)w>ÅR"y |„rU28{)p!sor#Agd´cşé<`bLeã8¨1 lu' eóåfg—laã_óNq3ffÏ%ëbkcebN!ğa"­nTå9x-*
&   1 ¡¨#`ô}pe¾£m6~p+3-~2ou*+K00a,@$ "ÂbMnsuR%hühát(SwïırQtGh érsåpîJ:! # ($`€UJirWi®l"cry u%(à"tampkz	25 bui|d dkr eÆÂ÷`õ0}hİ!fmf PğA¨êlq'(R}Me~4¤„ ( "pI3,¥~ {fîvj MweJ*  ˆ%(  óáğumˆxasA{vŸ$Áp?(xF2a­eChf`‰´(`ApGîV]eic„6ïsctbe s'5ªâE_dir&  "$É@ $â W,nkg&l@w[!`8goQ§Åd[UarlesHijĞ1b}€hE-deZ0^mÓ=cFaADo/
x i  „P|ôuq.: #d|E.soyrcgod)zO   ¨b$ `&‚Š *$©P ar¤sÍÌel3wu°CAìX2éQ5Ooáƒ( ((  ‚ ` 9P3|dl{sw"cE‰Iû`¬µ{Tlw.å7q"ÇGRf©,%^dhbGt©+F(pabE.t{h-ø+K"J" 3´oÂ UHa±l$`3îc41mmqth_La
((€feg ustmtu_ldieaêä¤-{eh6¥i*Y"f?\rõe r#a%d$ ¤(£ ü)pA9 ,jï¯n)"$. \îguN"%¡Â´#kd#nht!s%ln.o¨FÅNx$¢"&""¨ <$^gwÅ.d`kwwb
0    .(  ""x# $ BnnOtdeXÆÑ´u@`Eqoƒ`gÔ; hu(5S+@6åqs(tçr0¢tÆ[aTé~v`is &J&   ²(a ' aà`.:B©#f.µD6Š	À( ,  `â(" `1<k5ädŸSo%RãåŞ BF,
(p"!  Ø‚&K €0  &À9$¤ @2ÁPu'c&"  ´"'tss5oÖ0rgnR­#bk4kâE
h$âA ¡0ecj3Åv4qÍLnSëezs%[dm^F ) d" `Èn Ógn'&5ëÌk"ïFm)g!;€GFq<Å&>P P4äc4=((4"c@[tñ| cè²aPksäon$p€wåğ2ïxdeğQ¶
b $ $ &!``2KuyÊÿY  0<! 8©e³c5²t€-/'")n$r`Lb&,'«.|÷,$à6ñad5|n; #2*#¤€wå+t2lhnjZerL*h4p1q¨vcWG}qd õrq ¹(cålö+üm?ë.órlóp)|(g+#"" 
 "0¨¤ (#C_"ù#ç`tD€¹!bóO·aT[rc'èÅ-vUc_tÛr%® ¢ ¦ $+íj fA!âkekõn :
`°0"1  Ä mf…]t&{e-G.haOoaw\öcw	¨   ¡"  à0àrÁt`/Ç<8*
¥   xb¡ a  ä    $  khwaÈz2o ìâ,FCU"rq1•Ev}e¡oô hWàneeoF±`÷RacAe$>!ãY/4C ¤  )$ "f"	A( àfnsx
(2k @€H‰"0¡3ú¬¨†  8³ìl"nUëßubl€à qà)tå00!l e m$"0f   `¢! @a a nGSäCtmoŞd <%JoF[&%(  8  beP" ¨Mv cdmV¿Ìhjku|,21Veôp²øgê>g¨tI5IuX ‰:Š @` "f! b(  #¤  ¤  2v´Thqa¡épd"¨Ì+` $€,h   (  x $ ,` (' $gé\*i t@ó>ïC$d@dè#-0em.‡em+|®<66(@4 ‚  6j  ¡  	 $1$°d¢uÃp#sRĞ2&ogIàt8a]`@ı¯7g}«.,ïş12ª0àl$ ¢ *4  00("   b¢p%!%ck~&}ig`kosgay»e"g¨T Íşº/egùwh®xEl0zíª#l/ÿ>¾{O0"2 ¨1à ¤b °0I$á#¡&-  `0`ì¸€1@ `è1w"2"ewâtôd,R}"woo,ptrxceuhcfv.@aOîoÿ©ën0?0(& !35égq8)H "1à b !á0,ˆjiDd'
Ö}rm7¼ahy$uuÔ%(õƒlf8níncftr@
£ ˜ $; + "æxm$gb6E`."Àá,p"p¢* "© ` (à Şc0ËjpckwÌ%.Ptcyf,GMtæ³mm²C+?dirì¡u L9bidå~[ôj,!
 7 ¸!â"!(8! alr'(B 0"  8 °!(c $ Vashic0uf`&eøyiP}£söLf*Uo0biTN`r,$Vìıii`ugîÍmbL!  !,(dmE'
m9"B&pu 0ô¥r6ßrö4- ğ!"   ´ ¤ 0 b ']lO\R-GZeDí<dzøn:çontòw,0vsd`.an eáq6 !wmd%" 2 h*0ˆ "0 *$$à¢;eç.Izn+(Àö/ñpù&9a)
ê8 <*'1|kx!MÇŞo³EKPÉûês   " `eR %.Idtalf8vem&.`AUtoZ#o6bå:ü)fƒ,Wim`fg:c,sa´NAbt¹:ºj: dbc`(# us04: 8bOol&Â&o'|ì&=5(a\mkm!,{_omî÷t ÎLbuThSô]¤ä7 "8 p³(¢8%"    ¡ÕnLbg`Ådl!$hf`ä)h÷²i2]u2îÊ!1a{fe.t~4a~s³&Vio?2ohqQ"bæguArdluo9o(©10 Ğq,"Ğ¶BM0ü3"rEEgúF¨ÑDmoÒiŞf æ m/ğifYaFg`7kltó­5~\1ssŠ<#ˆ"àq  èzĞôk_Gÿngãrddb è×(TWSå.
"Å` ( 8hPxsas°øg,f5,åla oò$}%´xcy`vãgYovv{i.e#èn0a`óûc.0{ô”)x.a / 0    °¢4yus uNiGóuad83älof rktiéf4å"gI1e]an dNwhòwIiÅlu$Ba´çêíyJ(b   º lMàify ön!|(4hBwÕ5| Eşæh2-jáafn õ2pj qf3t(y kzt!<-ofp)c¡a¢$ ¥nhlk%e*a/td÷bam!û)~%,p!ãIi$e&( $& 8 * "¢*(Ú$p8¬@"¦@YrÓez\"wm}~%Rdq!de(0rb`PBi*   •% ` ´&kóp;$phİRe±õÚ·D[îgut_pIsÔp(aµdygæ:buì . %õ¼oào`L»$(4 1è1¢c2beòr(0if_beWOõJUyb&Dlvöb8bv4ií~L<tfU.å: &? ,€¢" $ ¨ }m/æe2n_aVnénwa"[#lğX)ok5±$ay qôaI3 bKb(afgt-\hu$n"zE¬fn.«,!¨Ÿ¨¢ 11 h! p3såüujJ+zOF &¤( ¡wàxeLS$:!* p  %   N  ïo&a_n'è}uF( FuÎF m09ºTéò'r/Ş°¤e¬eDdbdŞ9 %s§Œ0bySt=Š
:6a!¤!P}f(nb\ië<alqi\%wg4$9$eêI&{äolhTéôx[$|(æ"nM_`éá8ôlq0+J8 @f)$ 1o)fs<MÍaèD–Qaühså|/SuMvE¨gv4gO+~&IÒd,$ä`~BVM)*>! ¨ Qcõõso }nãgÛdcLÄwb_råvj?`v  %4dm­æ±_gí6crG(é`-ßn!ee¨3E¬Gİh1!&h,¨t$V`.´äi¶l`ı/lt,z	Š@ ,*  ¢!aphRl$,\ş,(lB) SaR) 'Z&gtf*@`¤( B  dneEìäâ>_>±¢Ûf(ı%hgW]u<pòÅ6Éh+ºo  0x¦%q€r! 0#9~yp¤{h`úå$w}r)V:> stöf  °= d  c9m]sfRt",cm5'óUIrğWUIÕd,}²¯2m´+ (wlpcõkªz-4	,¥(
" .$!)` !3 '( f{me´%r ao%“n¢\wr`Ê~Gèvx y2%déx!g[! % (úq}à.`{{æ#ø)0!!à"4 (% 0 ): ¨á "a¨0€£² ï`ua´/"mc¨DÛJ=d¦Pòafkz) »}±8]n5 `!¨j0èP(`niu¡} n¡iao‚cğì` å*ÿ3$qap:F3Oq-%¶À #¢f  8 àb{ít}>î +áie
ˆc¡e  î `rEtè(?aos.rátì
Znif:0qàm&tlmr,+bití#† 0 ©  p"lä¥e4} {Ãle-d?zë°_näme(rXôH, rïgpdIwmH`$*$pJ"#vuÕWTg 3u,`¦fu'-) &*¦` .%NUœZ   qæ czch!7ç™PgÌf(6µh,`Tc-j(ú !"1$%`à% Typ{tH¢wR)(-6pNn~g
)8084% .¢Keqd³ˆ˜²Qtñr)¨Ì/"r|öédådé"ëm(f_emr*R(8b0à !PdUqdv&¼Oæ 2çô)jw6ômwnnmadA„.ZÒ*:?yei2i}wox÷ tkHøruof²hpYR ¤ON«Iid D$ * "  (¦ †¨i   9[ÿme*se¬v!Fo5>B[]DÉ`Š
 "#"(,AgãpiE1vã81´( 9 \bu7ƒ $ t 0%mrci@ntoK`ie %e¤•w¨d"Yipe!/$,óa)s6.Álí<"ua~g?í5óadé”j˜¡vDâ!mnj!>5 2#º $¤ eúS`Ed_plùj*}:&}.zqth.xo+í("UÁ|dõæiğ#eZcI/~#İ,áeu-,d (   bID î)* büboÄ?isôs¸!~Bì9beN@!pà=7qg¡!e(È%¤"bu;ğoosU m$	6{Opávb9gx;doš¥*:0ªu0(#à $d( "gTIe¬g}äl!/ó€å9m7!& aªGjoj181(Wié`e,2("+AWû1q-,+c`2Tl# %l,)B  b@5( 3! ¬x#ğnaïİÄauì(ñúkjhå4vàÀti	¼(#a' $·w§)7@'-„§e.Én
`$   ,aª $* Yf$jA¸ğ¯n{i@vQ%Ä7~À¢¨)(¢$ 2i0 x0ÂcjÅ!tíE!Pcyùòe
}dD)trmK¤"°!`„`4&  !%ihn,‚esx,¯ûMà|= ï'{†"$$¨e!b#=°$a1 aNo§q:/İÁwkl^g¡'DelevIfÇ0qû%*,äH1ö,A8ÓDhLhq{cŒX”ôW9!ek¨hI€@%´)01"1p´ &5kÑfpedIcå`äSË¬ifaM´qTÈ)
s$ƒ°"(   !$`dëVƒàg3Tgyu=} Jvs: °©p¥!c$á’!°p2CÅ!c¤_&ãob">d#_a{çàSe!<3úciIF¡_agülk !$`¼5 à10-0"."D;c§0&gárjiN â(´ai!jH %# è$  $ ®Ji6kièÅ9uü6s*VÏ s6,O$ `) °€  µ ,e!¢ °#thsp¬a=wxA6`*ezAx-.&\<ñ~hé®0R `pè@a 0 d$!# à	mÉs!lay×4ávè,wqj$Ôfˆ$å	´" py!<°¤ˆ!`p 1!(0!`$‚(ğ#â$;    “iuEm~gòE`jskàinu[Ù!.h$ äåat7Yidu: à¨! 2!.#«Õ(í$ xÅcpm\q5'¬=@oo·{J$¸ &!# $ p	"|P‚uX­fq-t (	9Š$` b  @Tif ÆaT!Çæei­]"rãè-6eŠ ©0„  2# 2e}tò.J( ! ¦1¾éxvgôptU,m¨xA™nile.rúPfi,u. %   $( $t¢$EkhëKj`ÜğauË Ew#¬‚~IzfKìE,Zix[EE6Dl(0cnlŸwÚy@>4P#ue-Ê2 ’&D0t8J¤¡0 p¸Wl~l(b¨pnuuw4™h 1°À!f$á "Dq÷ 6tïs6ğatÈ/n.pmC!cez*  *rƒ( ¢  0$  úøCÔi.P`ó@îv2	rmàöN}æôá{kWWVMu2gL\DIòÅâ6/ré! 2b`d$€$ " ¡!* ¥"`` ` 3* LG0h[óxb}Bqe9ò~iYñq*¤f)-@nIuuc {n1_s…w¡LÇ d r©:¢$(> ¤¡   *¨8ˆ%@a@ ouIpmegGlijOERiQ$æh{néKeQ*  #2,¸8( r" à$$a¨$ <I{^#å'3-remn7Eh/q)y<åf&oè|Dç'©
£¡0(0`" , "0 ŒGoğ rejd`I× êo2Tiroak`ó@!#2	d  „% D`©"(b çkbZ!kJêmm14{ rO®|}oet\ppÂm]vGo`­gø
! !  €$¬
%$cF’P`  $$1tmrîa8},HpcVe|Mbâ	í)îpaxh,)zm,uPy9d±f. ®((° ‚   ` h(  4 )
 $ $$d $    ô±9p`¤5¦{kales ?ö{ipL?lgm5 jç{,u_ğäRw*h5`)0g»0101    dd8x$§x`%¢0Úydf]ZæeypìxfE][ATWrppxœe < ñ6 c"ÿ%u$Š"(à`0á)( 0€.h(%2b).xpŸîtpt.bita3÷ú(jiTËEò ,'')
b)€°( €2 !   Fölfùèe|gEu ij0di|±†+øñóJ€`0" ¨#¥2#,à      )a!o@¢i K/age0u ’}PDUPywÍIRpRwÔiLÅOÁME¨d±` t±""0$;`²2! qc0(à{n^Pxî}y*4 `   *" <<$21 "ğ9`"fóåt vwnamE 3 s,â,]æ1¥ßAbèHhtuInc-5(Š( 9á$ à  T" |"6H!6 ¹( fi enemÄ (ğ#øf't$i`-dÁğPeVl$rïcõìk2-eÈ¬" ¸"+"(0à"%h (a’@" ! (´ `(# 4,.   *   fYm&åme<="c>3)¼zoiò¨&rpişìl¢d)nTîcme) h30!´ °07° 0  4$:qi–kQtĞu4wym- ),5oaåi, âéleåùcni&eˆ ´`0€  r0nm&a}b-HG7>,/ÓáÆ÷l0eóg8`dMxüa)WddxaÂo,I2kşqu~(;ë8p8$d%puo2tál|+"1"H0p' üpf0  ¢@0"jvQtCàl/ôvb?fs @5(typt¸(MÍ:aÉq<c[""`40   7.¦û,„ép4l/~s=Ä,(É,"C"tyrÇz6O@tI+.e©BIb9Dôsà{ÿuò[q‚° ²
 0¡:&ot?
ÍHgdc&rutdz op×UmjáoCƒt2Y`&@#¤0!k?io9Këîe,Dc$|x8a!Oìuùo~alÛCdAe:`d "  ä tvgëj<^ojl°  ,pyi: Oy~i.æayZspbÎ[,( !*1 ¼#gß¯b&zPDWNk"a}qoú=|pVl­ ) |x`@(†JkKl10"!`¡1ğuye_eweQukğm}Sğl;emˆ £	49híq2k.mJ°" ""0 8y"omr¡ÄG-\rte!#`uqpõz€zJo)¨B  è9r(&`0 h£(pxô:á9:
,9 9<$În0 ’    hr:&eU(<0gydwDãL%kex£¸@.@a­"q $bg¼ó(Zc||&$@@ @(ø 8§-`Ázm2=}s_7s$2[knvı<‹   8) #b"!#Cho5Èûi,$
	    @€!l£ò*ot<öN'tJ´H8° 0   0 jqoW‹`tfãdyg¦moxaô%DH‚)h`0#4a) `  :`%®kû-|,ñæ)f. p5* $1)^)$d7´0 à¥x'bqL_D4}n2p= ïl,"-`ïxvé¿nv-IcO&Ïbáln[´mEô³ ‰s ~ox4Ne.eñDÛu(_} e0`Bh`"iFºsDä&(|emrejl$©(  h¢ài`€#" ynqòyhmK$`xuå&}'^¤efary`
¤ (£   `@B4'(($INó6%zlzcğ×9ons(
2pá "¢0¤& `80/ 2gìOBan]CZvyïbs
`‚00e@ "@H("¤ £0tsEgin5{zmvkxi*ğ 0( ‚  tdà !q êg±´pQ%j* °4p(ğ  70   tfe×·sog_srTA}uumßr2c`Oskòäœ
$¬ ,* ±`p¥` 6~áoå5sEè/.îS|cŒ!( (ƒ0  1$x
%h(àr1¼60}Od 4xSmlb,såPxt8wqeRjl d  €  !D$ vS   mÇïıAäî´q6iG.A[ÿoa|åe,á`! @0h"2À *"# r2E)-d;gl~#rmjF`UiEd[ôÿ6®#dè(à 1!  ¡!0sár_|ö +omdOsÿ]RgSßtez¥#tÛòxgådd.u2piòCo@]cmg0â&Kfc6ctoó1=  ‘€$y€âd­  K^ ´ˆ¡! ä ´ ŠcáÌf¬ü.aVwDdIÓwÓãG%äeaAÔrue
            return

        if self.is_wheel:
            assert self.local_file_path
            install_wheel(
                self.name,
                self.local_file_path,
                scheme=scheme,
                req_description=str(self.req),
                pycompile=pycompile,
                warn_script_location=warn_script_location,
            )
            self.install_succeeded = True
            return

        install_legacy(
            self,
            install_options=install_options,
            global_options=global_options,
            root=root,
            home=home,
            prefix=prefix,
            use_user_site=use_user_site,
            pycompile=pycompile,
            scheme=scheme,
        )
