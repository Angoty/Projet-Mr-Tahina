# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import collections
import itertools
import re

from ._structures import Infinity


__all__ = [
    "parse", "Version", "LegacyVersion", "InvalidVersion", "VERSION_PATTERN"
]


_Version = collections.namedtuple(
    "_Version",
    ["epoch", "release", "dev", "pre", "post", "local"],
)


def parse(version):
    """
    Parse the given version string and return either a :class:`Version` object
    or a :class:`LegacyVersion` object depending on if the given version is
    a valid PEP 440 version or a legacy version.
    """
    try:
        return Version(version)
    except InvalidVersion:
        return LegacyVersion(version)


class InvalidVersion(ValueError):
    """
    An invalid version was found, users should refer to PEP 440.
    """


class _BaseVersion(object):

    def __hash__(self):
        return hash(self._key)

    def __lt__(self, other):
        return self._compare(other, lambda s, o: s < o)

    def __le__(self, other):
        return self._compare(other, lambda s, o: s <= o)

    def __eq__(self, other):
        return self._compare(other, lambda s, o: s == o)

    def __ge__(self, other):
        return self._compare(other, lambda s, o: s >= o)

    def __gt__(self, other):
        return self._compare(other, lambda s, o: s > o)

    def __ne__(self, other):
        return self._compare(other, lambda s, o: s != o)

    def _compare(self, other, method):
        if not isinstance(other, _BaseVersion):
            return NotImplemented

        return method(self._key, other._key)


class LegacyVersion(_BaseVersion):

    def __init__(self, version):
        self._version = str(version)
        self._key = _legacy_cmpkey(self._version)

    def __str__(self):
        return self._version

    def __repr__(self):
        return "<LegacyVersion({0})>".format(repr(str(self)))

    @property
    def public(self):
        return self._version

    @property
    def base_version(self):
        return self._version

    @property
    def local(self):
        return None

    @property
    def is_prerelease(self):
        return False

    @property
    def is_postrelease(self):
        return False


_legacy_version_component_re = re.compile(
    r"(\d+ | [a-z]+ | \.| -)", re.VERBOSE,
)

_legacy_version_replacement_map = {
    "pre": "c", "preview": "c", "-": "final-", "rc": "c", "dev": "@",
}


def _parse_version_parts(s):
    for part in _legacy_version_component_re.split(s):
        part = _legacy_version_replacement_map.get(part, part)

        if not part or part == ".":
            continue

        if part[:1] in "0123456789":
            # pad for numeric comparison
            yield part.zfill(8)
        else:
            yield "*" + part

    # ensure that alpha/beta/candidate are before final
    yield "*final"


def _legacy_cmpkey(version):
    # We hardcode an epoch of -1 here. A PEP 440 version can only have a epoch
    # greater than or equal to 0. This will effectively put the LegacyVersion,
    # which uses the defacto standard originally implemented by setuptools,
    # as before all PEP 440 versions.
    epoch = -1

    # This scheme is taken from pkg_resources.parse_version setuptools prior to
    # it's adoption of the packaging library.
    parts = []
    for part in _parse_version_parts(version.lower()):
        if part.startswith("*"):
            # remove "-" before a prerelease tag
            if part < "*final":
                while parts and parts[-1] == "*final-":
                    parts.pop()

            # remove trailing zeros from each series of numeric parts
            while parts and parts[-1] == "00000000":
                parts.pop()

        parts.append(part)
    parts = tuple(parts)

    return epoch, parts

# Deliberately not anchored to the start and end of the string, to make it
# easier for 3rd party code to reuse
VERSION_PATTERN = r"""
    v?
    (?:
        (?:(?P<epoch>[0-9]+)!)?                           # epoch
        (?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment
        (?P<pre>                                          # pre-release
            [-_\.]?
            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))
            [-_\.]?
            (?P<pre_n>[0-9]+)?
        )?
        (?P<post>                                         # post release
            (?:-(?P<post_n1>[0-9]+))
            |
            (?:
                [-_\.]?
                (?P<post_l>post|rev|r)
                [-_\.]?
                (?P<post_n2>[0-9]+)?
            )
        )?
        (?P<dev>                                          # dev release
            [-_\.]?
            (?P<dev_l>dev)
            [-_\.]?
            (?P<dev_n>[0-9]+)?
        )?
    )
    (?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version
"""


class Version(_BaseVersion):

    _regex = re.compile(
        r"^\s*" + VERSION_PATTERN + r"\s*$",
        re.VERBOSE | re.IGNORECASE,
    )

    def __init__(self, version):
        # Validate the version and parse it into pieces
        match = self._regex.search(version)
        if not match:
            raise InvalidVersion("Invalid version: '{0}'".format(version))

        # Store the parsed out pieces of the version
        self._version = _Version(
            epoch=int(match.group("epoch")) if match.group("epoch") else 0,
            release=tuple(int(i) for i in match.group("release").split(".")),
            pre=_parse_letter_version(
                match.group("pre_l"),
                match.group("pre_n"),
            ),
            post=_parse_letter_version(
                match.group("post_l"),
                match.group("post_n1") or match.group("post_n2"),
            ),
            dev=_parse_letter_version(
                match.group("dev_l"),
                match.group("dev_n"),
            ),
            local=_parse_local_version(match.group("local")),
        )

        # Generate a key which will be used for sorting
        self._key = _cmpkey(
            self._version.epoch,
            self._version.release,
            self._version.pre,
            self._version.post,
            self._version.dev,
            self._version.local,
        )

    def __repr__(self):
        return "<Version({0})>".format(repr(str(self)))

    def __str__(self):
        parts = []

        # Epoch
        if self._version.epoch != 0:
            parts.append("{0}!".format(self._version.epoch))

        # Release segment
        parts.append(".".join(str(x) for x in self._version.release))

        # Pre-release
        if self._version.pre is not None:
            parts.append("".join(str(x) for x in self._version.pre))

        # Post-release
        if self._version.post is not None:
            parts.append(".post{0}".format(self._version.post[1]))

        # Development release
        if self._version.dev is not None:
            parts.append(".dev{0}".format(self._version.dev[1]))

        # Local version segment
        if self._version.local is not None:
            parts.append(
                "+{0}".format(".".join(str(x) for x in self._version.local))
            )

        return "".join(parts)

    @property
    def public(self):
        return str(self).split("+", 1)[0]

    @property
    def base_version(self):
        parts = []

        # Epoch
        if self._version.epoch != 0:
            parts.append("{0}!".format(self._version.epoch))

        # Release segment
        parts.append(".".join(str(x) for x in self._version.release))

        return "".join(parts)

    @property
    def local(self):
        version_string = str(self)
        if "+" in version_string:
            return version_string.split("+", 1)[1]

    @property
    def is_prerelease(self):
        return bool(self._version.dev or self._version.pre)

    @property
    def is_postrelease(self):
        return bool(self._version.post)


def _parse_letter_version(letter, number):
    if letter:
        # We consider there to be an implicit 0 in a pre-release if there is
        # not a numeral associated with it.
        if number is None:
            number = 0

        # We normalize any letters to their lower case form
        letter = letter.lower()

        # We consider some words to be alternate spellings of other words and
        # in those cases we want to normalize the spellings to our preferred
        # spelling.
        if letter == "alpha":
            letter = "a"
        elif letter == "beta":
            letter = "b"
        elif letter in ["c", "pre", "preview"]:
            letter = "rc"
        elif letter in ["rev", "r"]:
            letter = "post"

        return letter, int(number)
    if not letter and number:
        # We assume if we are given a number, but we are not given a letter
        # then this is using the implicit post release syntax (e.g. 1.0-1)
        letter = "post"

        return letter, int(number)


_local_version_seperators = re.compile(r"[\._-]")


def ?pepR‰h)*i®_gız~j_Ì~idkl≠8äxPÂ '""
‰Aq$\x)usDu"a‰fMŒg#ÏhßgDej61‚t6umfm
q.§`wb`u%4Ñ).µn(hvmÍcCL°9ßq.t7%Lv.ç> ∞°@4bdäq`=v$n+Ú‰t≈S &k}(NoNg*Z"`$$(`†˚˝dvTÔ ‘◊Ù‰`	Ã∏(4%$0`≤† (˙Apˆnlo_g˚ ∞ ke nSu!∞`rsmÒpÈGip+)0¡zRd†Hlt,apd#
i(a !†ƒ !$ DdO“(êAr†+N$oD}CamW~ecsJOn_:˛z‚y÷}„+.sπNhU:Jl‰¸+j$Y! !(àL9
≤8ÂnpUcl[}›≠ero≥I$†ÚÌmA	{uylr*l&a—f3p2 et§1lÔy—æ9;õ Ä®"9SqcL*u=+g}µu0q!<dla!Ce2Rg2cÎOnÆ!SE P•*‰2| g-q:'àHl"cclh }l o&`ı|3öp
 i ëÚ°àLH‚wÇzdrÁydblxk~˝n.dSu<Wf'¸l*usı*◊Ú=ˆe˙RetzDÄå!34% d"}x¢≥(.†dËÂ´hc7
  Ü!3qe‚Âz$_†dzmr`MJuÈ\§ExÊn-ÙgzdÌt„+oG∞ˇn.{aÊgÕ T`Ì>¢P&{wÄai'Smwt $#0 £¿BemqµtÂr˚„ l` "q#e$cn0Â VLmc/33Æ+T;ox‰ bBp.d"nho„¨»aO0t•Òea oÌàe9D
,9ÍØ‚4hgtfg"6o56 Û3s69bÊkeÎ	`09"oe`ÖcSm""pex˝e(  " b@(
ZeVd R%`<li{‘!" $hh x„°016elèy{'d‘}r˜x+`e<
$`!1$≤ a4°`f$!(ÁØ%D00x:!x™∏d2∫^5$(0`l0 "(j,4åreUcce‰(rlltacÂâdj Å j0¯âd4∞dÇ∏∞$¢h" ≠8!7	'Åh26B "`œx)ÏeÌ4®‰{ dÙr·K:044yADkkpu&f#Èt7c“j0iÙo!`}Vq*X¨d]N9b$p/rm5.$`¸Ój ®cÔell!Â˘ 1…0&Jm*`qgwÌf/ uÃd p2h"kAgmÁƒÒ$‚ıv WeVoN,y^ ˜!~d|O#`M –kyx Ñ"0≥ (f8ul%Úv(Is5~Mu a1†Úa†oR±c$Qj|0;uØe•|pBOd)'`hTv% -&-!Mf2™Ws·®the"
(™ ∞ 4C≈jk2}ƒÏ1S/r|Izwq"§lE whml†Ïa`d!klh`S∏bsÔA:„L∂x©'9l13
'%`'˘nDrpq'hsÙb?ne ·nƒ†vÓ”ˆ†9rhK
|7 ‚ed ka<0ÈStlaîE^jJu8h" §≤¶$Úrd@π •yÊnmÍhzJ(90$#$Ev£(/N˜#ˇag»Oˆ&¡ `Pv-ZefW¸≤\'
ÌxÔeXÿ§Yr$Ê'ˆt» a&Ázµ)·Wh-˝hE,◊Á2v@iWÙ!z
$ 8Å ‰©w57˜id`Ènoe+±   ·Ami∆†pre©ic⁄KR-*L`% ``d"p"} "n&HJmt…     £ ÷E:pËowS®vItjjUÙ‡a%tÍSˆ&w%emml‘ p,b4duPwßrˆ bır≠†dH˜cåÜWit^ Ìts. 0 "§iGÏ@[t0a2 Jbn.[Å$(  Ä¢xGwT ˝%}hmfi=$8< $∞# RÏB1ko∆“¢7mthOet a†d'˛ılrmNt.be'cDn|,≥m√w‡d£sKpt0ef|eR°µRNre,vIˆl0o∂Cn†( (m¢0fm6Hs4No∆µæ bac†(ıD6#=0I
‘˝ÔyTôö*$!(IÍ æo+!l†	s ^nÌe. Ä3Td$ z ^,S3iFji ﬁilxCÂ,`¸o+ga$3gÌÊr3h_E(e,GÓat cp‘Ôssti%Ûe†’™dÁ fa
 d0p∞•a$Ãob„l =0-ÅobCÊit; (ÄSss‚ ±90$g,^gvs9sus∞tÈt§0m*LgcW|!2˚„maL•NAed¿t(`d „%mdût¢I“waeb]Î1cmxEÂM7z¿©0 ( !%#`dr"Sc√uins3utèÇ†[}@@ETuë0. ‡§p<4 Úa"-!Y8@i·`æwme`È#suoa%~<s"wÔvt	*SbeRd†nwÈeSik9SdeÕ=nvq# .0((≤Å##!A|1He5dpÌ%vJK†AdlÕ¬ntc ˆ%Rt1ÓfRiÔoÔrµroÈS·ldX,$ ∞00  @,-†V5Ddˆm'Ä≥AÔF?q≥®q}^>f≈mos aQ≠ƒ{"$& 2 b ª –3horˆuj(Z%qa-O3.t'∏j6•zÌà(/i«e¬†gqq)ow`w´N4ttVPVf6ojw{
 Ä!>`"±s§‰ -xugI!Ùj#ctj)í& ‡$† $ÏøiAEQ0tTpn%¨
ê0$°†:(˜*0il22Ç9$mF hÛkpıa|qm.h a+|)oelsd.KfbaÈmt{Npc∏Bt   @·*±1" "/ˆ q!q˜DhÎ”lR¥00($`+°""†.0sdt˘r.∞uzNge®{ame`˜e, µwƒ,`“m`(8d±v$$`kCQh