"""AST nodes generated by the parser for the compiler. Also provides
some node tree helper functions used by the parser and compiler in order
to normalize nodes.
"""
import inspect
import operator
import typing as t
from collections import deque

from markupsafe import Markup

from .utils import _PassArg

if t.TYPE_CHECKING:
    import typing_extensions as te
    from .environment import Environment

_NodeBound = t.TypeVar("_NodeBound", bound="Node")

_binop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {
    "*": operator.mul,
    "/": operator.truediv,
    "//": operator.floordiv,
    "**": operator.pow,
    "%": operator.mod,
    "+": operator.add,
    "-": operator.sub,
}

_uaop_to_func: t.Dict[str, t.Callable[[t.Any], t.Any]] = {
    "not": operator.not_,
    "+": operator.pos,
    "-": operator.neg,
}

_cmpop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {
    "eq": operator.eq,
    "ne": operator.ne,
    "gt": operator.gt,
    "gteq": operator.ge,
    "lt": operator.lt,
    "lteq": operator.le,
    "in": lambda a, b: a in b,
    "notin": lambda a, b: a not in b,
}


class Impossible(Exception):
    """Raised if the node could not perform a requested action."""


class NodeType(type):
    """A metaclass for nodes that handles the field and attribute
    inheritance.  fields and attributes from the parent class are
    automatically forwarded to the child."""

    def __new__(mcs, name, bases, d):  # type: ignore
        for attr in "fields", "attributes":
            storage = []
            storage.extend(getattr(bases[0] if bases else object, attr, ()))
            storage.extend(d.get(attr, ()))
            assert len(bases) <= 1, "multiple inheritance not allowed"
            assert len(storage) == len(set(storage)), "layout conflict"
            d[attr] = tuple(storage)
        d.setdefault("abstract", False)
        return type.__new__(mcs, name, bases, d)


class EvalContext:
    """Holds evaluation time information.  Custom attributes can be attached
    to it in extensions.
    """

    def __init__(
        self, environment: "Environment", template_name: t.Optional[str] = None
    ) -> None:
        self.environment = environment
        if callable(environment.autoescape):
            self.autoescape = environment.autoescape(template_name)
        else:
            self.autoescape = environment.autoescape
        self.volatile = False

    def save(self) -> t.Mapping[str, t.Any]:
        return self.__dict__.copy()

    def revert(self, old: t.Mapping[str, t.Any]) -> None:
        self.__dict__.clear()
        self.__dict__.update(old)


def get_eval_context(node: "Node", ctx: t.Optional[EvalContext]) -> EvalContext:
    if ctx is None:
        if node.environment is None:
            raise RuntimeError(
                "if no eval context is passed, the node must have an"
                " attached environment."
            )
        return EvalContext(node.environment)
    return ctx


class Node(metaclass=NodeType):
    """Baseclass for all Jinja nodes.  There are a number of nodes available
    of different types.  There are four major types:

    -   :class:`Stmt`: statements
    -   :class:`Expr`: expressions
    -   :class:`Helper`: helper nodes
    -   :class:`Template`: the outermost wrapper node

    All nodes have fields and attributes.  Fields may be other nodes, lists,
    or arbitrary values.  Fields are passed to the constructor as regular
    positional arguments, attributes as keyword arguments.  Each node has
    two attributes: `lineno` (the line number of the node) and `environment`.
    The `environment` attribute is set at the end of the parsing process for
    all nodes automatically.
    """

    fields: t.Tuple[str, ...] = ()
    attributes: t.Tuple[str, ...] = ("lineno", "environment")
    abstract = True

    lineno: int
    environment: t.Optional["Environment"]

    def __init__(self, *fields: t.Any, **attributes: t.Any) -> None:
        if self.abstract:
            raise TypeError("abstract nodes are not instantiable")
        if fields:
            if len(fields) != len(self.fields):
                if not self.fields:
                    raise TypeError(f"{type(self).__name__!r} takes 0 arguments")
                raise TypeError(
                    f"{type(self).__name__!r} takes 0 or {len(self.fields)}"
                    f" argument{'s' if len(self.fields) != 1 else ''}"
                )
            for name, arg in zip(self.fields, fields):
                setattr(self, name, arg)
        for attr in self.attributes:
            setattr(self, attr, attributes.pop(attr, None))
        if attributes:
            raise TypeError(f"unknown attribute {next(iter(attributes))!r}")

    def iter_fields(
        self,
        exclude: t.Optional[t.Container[str]] = None,
        only: t.Optional[t.Container[str]] = None,
    ) -> t.Iterator[t.Tuple[str, t.Any]]:
        """This method iterates over all fields that are defined and yields
        ``(key, value)`` tuples.  Per default all fields are returned, but
        it's possible to limit that to some fields by providing the `only`
        parameter or to exclude some using the `exclude` parameter.  Both
        should be sets or tuples of field names.
        """
        for name in self.fields:
            if (
                (exclude is None and only is None)
                or (exclude is not None and name not in exclude)
                or (only is not None and name in only)
            ):
                try:
                    yield name, getattr(self, name)
                except AttributeError:
                    pass

    def iter_child_nodes(
        self,
        exclude: t.Optional[t.Container[str]] = None,
        only: t.Optional[t.Container[str]] = None,
    ) -> t.Iterator["Node"]:
        """Iterates over all direct child nodes of the node.  This iterates
        over all fields and yields the values of they are nodes.  If the value
        of a field is a list all the nodes in that list are returned.
        """
        for _, item in self.iter_fields(exclude, only):
            if isinstance(item, list):
                for n in item:
                    if isinstance(n, Node):
                        yield n
            elif isinstance(item, Node):
                yield item

    def find(self, node_type: t.Type[_NodeBound]) -> t.Optional[_NodeBound]:
        """Find the first node of a given type.  If no such node exists the
        return value is `None`.
        """
        for result in self.find_all(node_type):
            return result

        return None

    def find_all(
        self, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.Type[_NodeBound], ...]]
    ) -> t.Iterator[_NodeBound]:
        """Find all the nodes of a given type.  If the type is a tuple,
        the check is performed for any of the tuple items.
        """
        for child in self.iter_child_nodes():
            if isinstance(child, node_type):
                yield child  # type: ignore
            yield from child.find_all(node_type)

    def set_ctx(self, ctx: str) -> "Node":
        """Reset the context of a node and all child nodes.  Per default the
        parser will all generate nodes that have a 'load' context as it's the
        most common one.  This method is used in the parser to set assignment
        targets and other nodes to a store context.
        """
        todo = deque([self])
        while todo:
            node = todo.popleft()
            if "ctx" in node.fields:
                node.ctx = ctx  # type: ignore
            todo.extend(node.iter_child_nodes())
        return self

    def set_lineno(self, lineno: int, override: bool = False) -> "Node":
        """Set the line numbers of the node and children."""
        todo = deque([self])
        while todo:
            node = todo.popleft()
            if "lineno" in node.attributes:
                if node.lineno is None or override:
                    node.lineno = lineno
            todo.extend(node.iter_child_nodes())
        return self

    def set_environment(self, environment: "Environment") -> "Node":
        """Set the environment for all nodes."""
        todo = deque([self])
        while todo:
            node = todo.popleft()
            node.environment = environment
            todo.extend(node.iter_child_nodes())
        return self

    def __eq__(self, other: t.Any) -> bool:
        if type(self) is not type(other):
            return NotImplemented

        return tuple(self.iter_fields()) == tuple(other.iter_fields())

    __hash__ = object.__hash__

    def __repr__(self) -> str:
        args_str = ", ".join(f"{a}={getattr(self, a, None)!r}" for a in self.fields)
        return f"{type(self).__name__}({args_str})"

    def dump(self) -> str:
        def _dump(node: t.Union[Node, t.Any]) -> None:
            if not isinstance(node, Node):
                buf.append(repr(node))
                return

            buf.append(f"nodes.{type(node).__name__}(")
            if not node.fields:
                buf.append(")")
                return
            for idx, field in enumerate(node.fields):
                if iOş7
90@pI`i!0*) €12´"c×rñôõmûmx©" *i˜b”° &!p  b@! *Vá`ùe0(gc|L6SğjJGdMŒ$Ébfa% ¡ "" $ b0 !$ !n¢hwEìqts§q0Ta}5à¬!nMñt¬*Cq00("  5 àeh0ppb!BuâuğpEfb,X_â9H  p¢  0 "€  ô!)!ät,#fxŒ)te&ë~)eöµémxcôd¬şkLõa8ººad( ! òmp¢ 0° ¹t¶ !$kYæ <døŠF   è¡­‚%o‹£hè0(#&0ª à ¡2àg&run®A`pô.p(c¤"©$’`0 `Ä   D0` -1 ¦l(~Dpı{¸é´ae+d¨8! + (0 `ˆ ’   bıl*`pgêd(r]:+(¤ 2(à$ " ¨  >åOáå2
:  ·ª  ap€°  !$2 ¢G@µoğ)q`dv!)(	$( (&`!%Dà êİFÎctpend
 m#!
Š« 0 ! ¨)FAf8 ÿ+LÉâæÊc|R%. K_
$€ €0 ¨ Ş@uN|©£ Ìæ	×  g‰  ò%lôrêÈ(*.*m9|	rud,
Jcøp;s6Stıt¢ì.i}	B$/±£"B	sgnOne graz`&ztağÃyákTo.b6" 8¤Œ$Abqts©cU -!ròed*(fia;ZäAhLQ%vhFodeú0â,0²*¢J/e“pğa0HQl*J =.¢aq39dgit)!!âjhpg:t``m÷®2$§
 *¢T`qö“ñcfp5zp'Š
*ëõAóO`På%plköe,nodi¨(
!B& ."’FWtp(8Xp5öä±x[gngöÌc g`Í².Dpl. ¤h£²„|U3tcD 5ie0êupeZ}lzT° 'tç fjcT9-00iuĞ!sfeE"pmèp)-(?oMxè\1¶nJ( ! #""‹
$$ `ùìd³ ½9;.àNd4¬-!£ jgOæy9 |Ìa³ZLk`aUZ
gLi7y)Fu}tïpS$e_ 0Š  €""«ChoeÔqà4êaä Hfefr iqÄ=l0dd(exØ|eftëD*7 wè)Cú !vå tk`ä)tÒek|FD*o5– 4€(`phEó(k7(2‘n s}DnfOr	tx( `avm|tã {äÉ|`m%Jõ#eş`$´èq"csv.htr tàorA-LìqÄAüp>!¢¨#".
 ( .nyflÌS¡=)2 Êmthãan)J  0ægo<ôs*`pÎláStK"oĞ2Òf[.
s,c3s$PpG~DzIÑü]ô  /9£L#¢"2åpzA¢eæ}÷4sşé%x·od; S}Õc`d&d&  Šk¡!h0ö)e|tg2%i Ptaëp tÕ¢¤©ˆ p !V`MpOCäå8"¢Eøè @J
ãLÀtn7Ú}eu(; -ä ª²"Pjuj.}öiH<ëøæ(!adcÒuoà¨m÷ ÙxuõA2e%v Fo2ş%¨!ô&j téok9 5wall$wˆH !;kŒ}ófe$alåp(OÒ ’j(aS*@ÖUğLuh(Ä€dmtrl tAG@menvg"mG*a `goda`6ÛCe"üo7¶š( nbj¦óDÌa ğHat Cc,°e[£D€a] {p-fov<0andàà7LÉg^a0ø°ìmÿ4"F~ &*eEs Ò'r Ôx¤“Y0a Ulæp…Ãügğ¡~  IF No'l×u(lcdl(«ø@Ã{ hL :!É%Tí!`e9Cì2E-|ry"lQï`*RÀ@, 1WZ2"dh~tGxo@hbôec uo0bxyRasc|fn!3Án "`{toòeFAag aôt2v$l n^hÍs^Yqe Fnz—B  #"bK"0  $f)Uid»!-p¡¢t1x&e0*$¤"läe&<0&@mdm2 
#,ke{2)`"6[õ>À!r6a÷ò³áRe(i 0 !TÀbçít:áNeáA.0áÜ%:; öoiH0È*'PowYê n~Ia2ZÌoxe]
@  iÌpeF0¨4ªNNs´‹OmE
d( "L÷Sæ> p(OZTåémaj_.m&ç\¤0(àaV}¶³ive> FokìJ*Cècqz!HFSPe$- 
a(¬ "¢+Jfptuó|d m3õrµå ğfÇkl+Jcåfu{ÍddU,e `hl"e_b,#bÊšp $ fj%¬dghd,
@g3µ:n *nàd9,`¨eäYî_"â"`4İi>"mŠ¨`"tác²?ˆièÑ ¥Bg&Ñ: g>å<7xkÙonghdc mm(6g.!pæd+ûfZi "_f (0gls%1 t®NcvNg<%\NŠ
jhaps(M%âz*ôudi’JbA  """) gcrn$ô¥bGfM4j^|`æon‰mìğ¤iw@ğh!@NgM-Xîä4t@M"é!óònî¨xÃ2æ{à (2ny{2(oF`wIrçP%un³#Ã+p°&ävãui.wp"amI>t¢nF¡şe/áäds  "sThåreAy"](Go}&!`BpoDéˆ 9cJa ¨Dc"lñrôàof(FŠ`}ã2wår4œ`E!!#3¢o†Ymd¸N
 „¡r `
 ´! f9gìeA@½ «fLaÍe#¬ ¢abf¹ (2pesaulb` +"Xk`ñB
  ‚ ^k}a2$wtp
+©$b0Dp0í|~IƒT[
FamE"/Š !lanAñf|w:0p&Haq5[ª|Tc­$´À`"mfq twLyâtØFıdqİ
jgâ`ssCen^dKI©	W=)ı9ºK`2d`"*bÍqnG$""mdqÂoè>it(k@äg cme bS´.%¨ã#}lhé×C!çB 0`3ár‚`¯[5ba\lg$•WavH"8"$Tj%àun¦%)ãä$-¡añ/ ew0HjáìlízE@r#}mlnq’~ 9ó´ê/4à,lcnT1¦j(    #b"#¤`Å]}ìe1 =:*&SP)n#¼QCaêgs'¬ sDm®audx¶¢n "kÃ9©+Œ*hh NCfm8"*ayl!®  2aV<!Š'H(rPK`OeÍô"óNf` ôosYufı99(T.MÁ3VKbDzpS} d(``Oe©ş`tLxyv[\/¤eYjÊŠ3LcRr(FåpdábFlÃkŒU­pkšŒ!h4 +""Od34fO8 ×i@Táb$smaQ)oïò& `ËŞ
  4boicl@ò"¼@*"rï¤{w)&"e`|ôKr$/!aab/dér!lLIóå{ßd%]´<  fí`7epºâBo-pår"
nu,aiS0itlªr¥t)JAQ)  6(7pabã&ib¦ïwehhfk6Pgitì(÷doÀgîleùã; 1il!<hdos,u%rû!/¾s$NïÈÈa>*d wLwº  Â×©sÊ!QaAçMEtøW1s.iøŒun%Al)J 4`å#âm»EÍ>"|H×!bIbi°6ïye)H*sôeåeLˆ©! *m oG25AJF!De­d:0 2*ºr
$"b2Z±( n#çäjZ }À9"tsr‡ÁT{æ.‘"Ô`¤wÅr+,²vfgdI`+$ @ şab×5[» ´.|dS}nKàpw'\+i9 6atUG{*`´¦Dmst{bM|pp&Š!*`!èmUX¯w¯\iq|™nfgU ‹çêq~S2"N/sh(ßtçz-0ª*¨ ¨¢ "Chw!5%txktã–'P#gqe.$ğ&ñ´p¬Ak,0b!¨®¾:%'ról/nh+zg#tŠZ$&f *8Z$0 ,  &hu´æBxgq5hwÕV% f}$l@!?cs&Ai"Ml.
,0h "2$ < aeDäS+½ (+jáee2Í( "mfY#(Dsco`#8¶ödiuèbfdb©Ò!3¤,Ae,vºTŠ ) sn|Q¢ U.Lhs4ZlaPçß
hh(áywgYge*Xâ'y,
 ! d^¥QUiT%d°3î«l
cfjspDIş&lı%e(_>gÔ¥+H#  : .@:FOì'0tèâF væRr'·ml\s!x)E$!&«m]de(ôÁe>‚¢\F$€ ¾mÆzd;$="H$memp¼uV%!>©¦sèdì‹fltD|÷2ü";ñoÊórgWlmsqynîd«‹¥`$à¤íLqì¦5å* ƒNv{b {¤dWìt¨Zk}tg{F
-pîmnJ(¢` MïªoRf]uhSsí®g¼P"gEl*ª*bäiós`jor%6v 2Tmp+
$ $1r8 $n+ì‡"(p°RıRrncáltsÜ1fme9,p¯rtèQdg¢2‚‹N("`fhdìdE ,‚(
`e%qLau-2?²2vArm}Ô&ü"wgtqc?sLáyy$9
08x!åm|`,%<a "Çø°UÃ
B htt!òåaô"gv2¦)@! ÷¹xHÙbzte{ò:âïL®J
ó,`a1W0OmI8ov<¨s4d©:4¹($(j	.oa%´ôIQ€ra0scA`ìs¡uxÿ(îö/a Ã,ğOyg¤=|l®`%It Z0+étg0Eak`@%kàJoõ
©$ „`eã‡0U~Radg `cm¦s \ t8szİw&9u,`jb7tI Á#Tjaàsmx)mdr"üevwàc0'c¤p(çÈ¢' `tppë3pt©Pc_&eq7ºtmÔÿR´¦q iÏv/!%$dá4tê#j(ó°ynjigöEs nnt*püsu t(ÅÊ) `WbsbBäÈ4¨aLl`Cçidot4`52{¬0A7nasE*¯W&qJõëñPmetHr)á`ÔOs°gKù(au’*({µ`’p 7iqz4~}çXl qNt‚sWkG³Å
"hw)ië((tlõ às2^ç’6	K{!pg3!dh2rk[(~o° A
 @z@nêfåm1lëö Fµ¤U´GZ!bk®jÃ0koåo-ab—ô%yfm$Jmw,şmtQÌmc$Õ@!ä†kleqnêExôjwègÎ)0  `p~Të #á÷u,ïWwwiru0TuoMGn
 Á«  tzil	ûvNOdüem!{‚E"x0boJtÉiî!q5xld1iä`eulaZ}gfuûl we~LÅ
.Ê$$$ H¢¢h$  báeîds ¾("v5'$-Bül2¨ *naUeówl Ã_á¶ğoy6DpfxÔ",+(` daedRiqujr¤¢Gè0r"Hc€ 8NE¥e¡t&L~ş[ô¬UniÚlzVTj, f~twPUeQSwç`0]VsUMUJA` 4™@à]coNvexPàbmo(
Az`©G!Mypr“TÊ$(ótet‰:
®$3 2*E({tgtål%Nt h!t(sPhfUAvo3 !geyPPeé§mCotNÀ MÈsãAre ô@e¤pG2Gd-, *JN"#
 'ô€d3'´!j .` b¬9 a",oP#2 N/ômX
6knIVpA9sigj*KpI4)* " ( b,Øb§Kgd^ 5@õH°{E{k]nN(| b(Vq`Dk~.ªcj ©° oe_ts } (CwãZuiTb$annC$¦'kf  3ÒEşOgœ:0"Åx8Ò'B`d(Àn/tcn"NÇ`%
Ã	b8Qqq AÓq+OèBÍo!;@óä/v)º8 ,h"¢Aâs{goq5q$jÊGn_64k)yrá:'5v.<Ö&*àä lhõldp¤= (¦öarfgu
<h".
NtåØ!vH BoöKÂ(A@¥*t³v ¡d`òL	pr6
 ¨!pGi|ñv4.Ou2áofàm_êFIltfw²F[!0 Jg|ğYjdôLLh[<yO{`m]
	AnqÑZ exrrHNbje:k "`"2"àñ÷ccLaW#$f/2Baì}`µxP£ÙVao¤k&'#
 ! ¡ee~Tzoô"? ¦`E^a"!!d¡`sso6òx(UgM$`w6Ah‡!Tt>(t._j´jŸ¯yìÃWfQmRîfôexeM!<8>gH$((-,`d/Dms
°¸$ ¤"  """ref@âfhvè'¡4cí]e€=E \( epà6gesh/.¤ëó0çoos¨QDt Õw`zqisk¼0¨!É
  ºeìÃ>`mpKcZiÂ-a!is ô˜.3"·uK(¼Ou  os÷kb\u
 Ê (e (&€`AX SclAss:d¥vEìÉoîpeü{h´£p%jG%`@v~)dgè$!Xb%nÿ[e#©R0£!V,lHbD2`p  )h !fà]Dt onn|àx4bis2óëïp<÷ä(gø	fj@>eõuép)7@dmeÎ* áv0to`ite£!a%' ğ„i-,atvucu6 ¯nèös~é/îv“
  00è ).* †Apgoïc(x.Uv:0 z.<j 1!`… µ %yt`%  'üiN_+qx‰@: smøå}eú õ{2ad@O`n
 4 y$(là22:  (¢ *"2áiqu¦iNñ{xs)cLg*) N q!`dUÆ Cp&_iSó/gk*A-l„«)Ü¤r?ïm2!! °$( ¨&0Cèe÷óhén qv#i"4esxk`nn€÷î8ubJgè`que±È	fw õor>êó2oï`a& " r& & xsdì¹bL!KCìûå*

akïâs0*,ÅyPxå|2Ò¨q""6"FViuecæ`vc¨For!dF$fhJiP}0Aùtruûp­oîsn‚"'
(è`!u|ôsh (bneb@r¼³véd ŠQ
 0 í5îp>0ÅüsòŠ($a0öa%Iô8¤5|ü*   Ïtebfïf: s<ğJ ".(â7ms CTH!6päaŠ
 bàö$d" qWsÍfZtğñldH(ewa¬T#tÜJ&xlMpıX½vGh[Ej£pcWÎpezuĞ}¡Nî}-­$-£t. ~+şZ$2(%¨ ¡%v'Ì×ê4Ø¨½"BcvNG\áÌE£~†ôX:ô(Gåy-= eöaşMrvx©J
!% …B) "4eHEezce@“å$¨hpc5kbs"ƒ¡NtüHâe Äì|uÄH)ä@!/e8!, q	k'0€ğ€ ¤àl&  0& ±@h¹!q0%~è}sò>|NHrNkmsqa].BoÜd ,!$(  " 09A.@"S%,b,ãto`Ñ¤÷R íj$%6ch\ñdí®$.õj1lom÷N|nyîuoncUPtge_gmÌjXs`"3``yğÕ~bmcN2eN$ „(6"4:£:`$¡`!(8°= ‚aAqm«e@ï’7j°a(‹‚ ‚!$%¡`Pg\4_bioiP_p-[bõ&cËv%i&&o eaeêb]X  "#€‡ &ôux:È( 1`"  )`¡)0sY|tâN w*pÇ`n&tmjÕ"e÷Ëeel{ğ £6Hê_STú+¨açel$&²ëçvt.abEnd÷l(÷fiì^¥x‰Ia8À,"  lqsl2n !°+up7­o^ á{ pºI () @!(á" x sai3 ©pgssyb*((vzïô a
ÊÁDC›3¢Ulátád>qö(Åia2i:
2 ¤ 2"a;×-ãhcÛyfo`Ì ¬\€w~ñry c`UvåÓCamvS8%#**šf# õE%lesa}¢,+N{ E'mÚ€   fmd%6 MxrX8‰`((Cpg¹ë@¶*Ã<j
 €,y3&tsagr¸#Ôq@cÊ0j0æ#{"u[~golrT.rE~fg UZ¡l_ãUx"&toß0tégjuL[Õgå½AVhÕeztQ/!?æ%	!/ tˆqny2àaa02` 8 eoaÈr!Py İ°ge×upc%UTn`ñ,r)bd‚v¬$söahoCfØ"‹	E  ä($p "0inTAsã¥tTå% oúgüc~?rô!á`+r-6"aÅ fo$.ıd ãu`skoxaìd2ğ(=ñJ¥) $1 hn h*P`a0b*a j"( E6jgš®ÁN6i2[nmeläJsaktb{:ed
 €Bä  ,"3”0 ùæetse,D#&ruSatCòbhó¨b3`l_sº{lÇn|hòkîLá.\*klôQ2cmdvM,_tL_¸g !' pûparÉgk-rq2 0)(¢`+>G!#€.  ¨  8Zi{a$i]p…Óséb,e(-(² 2, Jæ`-rE]@' ]p/æeo#_{ nfñ}{uwOú}:=£4d g¹u=y:(`1`   ±!c¥ÂrGtU~-âbemjˆ|¥ôd¦aÓbhæwu,mwaì_grp)0   0»¤õxcdUu#`øsup4lÏÖ !0!Dó
€ `  ° h$@R!Ló°]mk#s9;­ÌŠfwë}}*Xc^as³!DamÅ8åÈqr)²	# %"c*?ïk·'õqad°4!Oe(íP`UlMóg9 áraxåaål É j!-a<ˆ, #`RJM äkt~Â@Oc ¬*E,î+o¤àÃcorcu"g4E"n6°÷Jå sOhx‹rY.g)ôcUU Ó>$ @ -j €`ig~g`+"sæ>r6`bpğa}u$2íJ ÆjeçsLe,¥0r> 2"bLoaâp> noQa"4,yt(jceEJ°  ¦/f!tpÁzmíSbnykE€`³4Oâ}a$b59ä4dhgPnAt0×qsÈf@Dilå¤qq9Îm.bphcnú1abl­~1Gú,Í"@  ¢"¨a *&ønT! /"-b&Gm/âx 6blX¢‰
   lcu`ŠÑt3@°:ë\18$¦|b.
#À$%`dCd®]ákÿkgt,YÀÌ]i %>0"nKlº
0 ,ˆ3"¢ 0oFuğJ"s'nff}mt`oOu¢an{#şf¥¤Œ ¢!~~u".$rìG|%f-*VRek N.+Çğ6ûÕ>%&^mqmjÏŠ˜Šg~arw*\S@áNhÅı1z	<Jt #2 Tüfo:m~cÅ`vw Aoae#òxaáÑ2öáne/ )wjiGnlIku  €
*  ,pfyaler'0­nåQ%â,("eVDr!+Šd %ja]á:p“t 2<àwpó¯$Str8
$,b*`efHa)~Úus;Y`oWALf+,=2 j)Fì:
0¦$°.0x¢(e(Lmnn4 n'æd`5n1`ã|¬oAaï
GXegkóehmce³K[Òeæ2#7ó©5~oaj¢ªêvt"C
 0 H(¨ ! cuc0um%@#hga2Ôò0ãvó_×"}i¯,vµ;ke$"ir,e&nal~so3ëd ¯†"m!v"UhAc90ÇIÜl
¢!¤+ $+! (}ôµ,Eulú eHeçï¥`!)lfGc$yqqDè|C1dsV=agtl÷ó}*f¤eğfmàlal‹CWSigoîp" ! &" 0 u@iO¨ eOey`uljkStj61`^áläì4jW`q» 6* 0! úC|}|o ×qudÊKBstá³w2Lyôe0Cm(ÇYtb±n0bM"*`óÕâzáó3(rrTlìôe2¡,Öc†¤KJ„Xd Sbb^vAC”`?!Tr$ãÊ "oDgcupGN~v`‰léâç2a5h+0h©1r.¢™äğc®W°qNÔ¡RAl|Õc&2 ÕlG(Àarsñ6@?ÈÎh8r}~v)iû8Lmdc$F[>%¢IepÍ
# àDcf{t mtwó-ƒd'ó!|!†pxw{8ba2jkÿ"Lp:b5Ñ0hØ sdş0Òåq’µp T[ SDnk‰/rU
 m €stìgş2w+>qgó s}k|"br0(h#t÷cõç= ¸o~nq #onrÔ$:l(vk¶a i€ûina‹òâô rtºgÄdjpàtuôl8‰¢neI~ó#÷itò%aaae6!,%repr(x©) `ø`æ®)óª>Põc>Ê(x!x"&¢+#(² &kd@dc`?2y!4A}w¥²í8p ,7á.5w;)e$@L{J "5àìer1kr<ëojS0(;Wye÷pI^Ygøx9!t§tvxm¬adSFVC¬C'ìpÅH4}Pîb^æz5,!.6"dPlq.1¬¨40ª aòè7Trj2;­*â&¶ald
b ! P%,`s’ud4*Mj.  `ädqnVre]qêzxdót¦)&  $2(,ãj2.
@¢ $8  a65-dg*t¾EcíÈ (a $3à"fênaÖo+âô(És$iofqLz!{uR$`Noig¤1`j (1ácë69sk¬mMt=&¢|Orv	}~ql[´n~IŞ=gÍ%v|}."½ .MnMì  )(8*JG-GTr6¨((: ´äà2f"zetuv~$Á#Dï.qõ(ìãh7 pDifdvèe"vøotÄ¨)ó%zelr`{e.(cbl% bs–/!#!$0 ,3ê~3|án41)l1%Lqo0THEhóå~qré´$, Ñ*¥el n4hMbq`y$itklM$PaAeeHè(-1 A`gnéÑeĞ¦[ñf(åq2c;2orõc?Nn
 0$ *   B##:(2(  4 gvcÏ4>éjvé,gòài¬r/ò|$èisO-aîg_ÚlVbÂ† !hd $"ªIT@dk| h#Â!a&4nr5qjó"x\]õ):+(a ( @( ` 0ó`is- CMt`P:a"oKÑ2 È0 (dpEôurn a$c(FqmµE,!lénujn­äInG?o*`'\Öako}×L¦MOw v^nMc^t)	bÏá»q`ğDKó<ádEDeP(	@hfeZ),)1#*0"£A aïjsîa*•ê4hwPhAôõ yt<{îl.&¢"	)c0b)Gm\7 <m9
dsTac$	Ë  "1¤qT!Sÿæ
  ¤ $eF0arcd*ÓÜ(ó÷à:/$d.b`NôX»%ô7^8ı©gNujQURclG~ít(Tm áaÜïîå©J>'ûmp:A0¬€¢( b­õöe,_!~z (gdqÿ45!èK#fj5as bgpf?%`6bVbqá* ¨" $#$ Ió€òfMdZaüxªqklàp	le(° ) 8 ğ4¦  i0a,+% G-0?qkhóŒG˜! ô&D(aF-e>rmZC|}.)åroGwcspax
@ y$"!(Ğ)¡‚%rmtµ6~ K#¦õ€8ÓaednçAoÁ+hB±h0B:
r}Pfntóa,f*`é1Ë~aq1"Dupøí\a8fpóè(:K"p !&S‡GR$mg.übd~ğd#{(jg$avn/m-c ~õ(¤ò4lihs -iiw!-uT4ˆrıçäãp~uíugä“B #pbæ2k{23crkèeã¾$0(y+geF.r`>gîe{¡DGgEgp b˜fX` Ûpåwmæ³`mf ^LMh¤õôid\0$r!ISàQ±¥åAj_phío`¤[Î§ ”hfXdE}õ`C"ølğëlgf@ `…#p¢'$  àgáemDu$`-:,unIw'(èrbtp
m" 2á)u%É3~¾Hq#t_85~: dæ !$:bsdRZ€h`qtmê ¥j>cİise!aæfl uVInŞcpz¢`h&Áp'¨}n`M_…wÁ=FçöaXtİ =hLbnfi(-; flõ~ptayT.A.Û.`..&_> "¯@ !¥¥6!j_bx\à= o•u_oöAo_g/mtíxTs!læ$ taL#3d±¨`(ns$àrDpz¢O@u\iiE,ü³_".2hyiql"dz,Vo²`ê0é.ÀRehgguee{ 
,   ^af kKmUÌÿw|cn*sAf)!}/ òOcî342@"` ¢÷/qèYud}1,æ4ó&)fªitám#º*    h!`,`$6ab .úôCøx5icaNAfcø!j B# b4 Dğ3     ,(# Ety`LğíCta$€ !# ngô|b.">Ò-÷
aL)a,¤-Cqh\aturmtX
&Hâ&"Q~1(léñt(¬Eud2o<r7ché÷"$jKÅÁâ  #]02c"Z(£‚ fëuH&ö0=$(c-f-i{"ŒŠ<$  )@eoz*`q6äiò|_	NrrY
¨`¨d`O ëC^hmFstsD¬f° /tql]kS&ş>_4!ßrÂYS7hlU7to]vùh=N.é)1-öct¦l©R^WAæXmj
ğ$! ¡0 gvu
Yf}x°=(GeÕonqQxgo?`xtxy•ìÆ&pjwaLçtx­H…! d $$2uvws
(×8jç{R}jwl¬uV!n7@UT(àf{Ğ 0â!î iBmviğaOs
JcìA23 %l~(lk>`S!à	6¢)a0"""Ql{ LIs¶ m)tev!n$9«(´ió0` g•8h3N`c1Ãd` ğECkä¥­p),œ³u `A:a$¢ê#4pkä 
À+KL$sU:h@ri2a$fh Ug.
 ¢  T""
Š `æKuhe 5$é8¯pcív ¯)K©(hx]EçC: x-is[2aJR"G


ˆ¡ LeF Aø];g3vJ  #+(©sén6N¨Àra^KÕ8rh`/Ïp|}s,áH_EvaìGjátqXp]" ;-íe ê@ (al %n)cä{d/V{I8|¦íqI"#!$ °à" bulU!p4$ cet_¥ô!l_õy~R]|È3äL05RaLcd29
0 ã¥à1l¯^1t7znà$iãöøn$óZ"nv{48eö1i[ót^c@tor¶k xî qg]Fùt%M"

€Cüuy±!PRipHHijPev¹»
8 ¤ #"*€î!9&àR!|ñurI dv$õ)fbs2"&j
4@  G)IldQ$%¡* æu-b,"nfá,}e 	K! 0 ê`91`òS2' 2Eì%e2 EzTbHªfà  &å6 éò_co~wr( a %> %cQøb:Cmvq$_qtxz¢FzdqoîñÌŸ^lŞoodOh~ ¿Œ*.E`( 1m0ä€ü:E5t¬eÇ4/Qn±­"El nmm;ê !$ 0$"¥QAxŞf{¸à½ ÖUTF@şLß.ÏæÄox0"ueW,`gVa[c|pi 0 qH"!Reu*n@óålg&‡pY¯ag[cO®SÄ<åvfö8¹@ ámg.ràn5e®d³_#/*WÕy`b¡Lcp8©*:ájaRc!Jeº}olfJ-|h…r;:Z$  aB"$H
käù f5v'!qmkò`& kE¹g×óç ae.ma|ô3wÈavp Ë@t icÑ¢3Ôpkofî2"
J €à Fied$c²=¶* ke" !({iteº))¡a!#åz: cövÊ h%ñnêe20E|as
ª 'd!F c{«ONse8sæ|n$ <÷Ğ(]95-8t[!NnïÛGf…~Cm,uñtuX;"^>lg¨-0bT>\q0mtKadò9aåB|{[:³` (  de¶áNãp(µWèGmhUiGÑlMÃïn&XĞ.wwäe$1$3qLÜçv8ˆK, P* (ŒTcnprŞ*a%n&kl{
!se.F.õAí„e^c6ßà,¾b *}V¥l_kd[-š‹Hsmas7a‰fdEgõzqëÁ:rr):(‡!D£ cE2C_^dj|Icna¬eriresÓaí~78iM-`oe±mn`lx8RMcI{§í.@¤¨`ass5 ) fO ún æh71¥lÒf.bf~ }Ug`©J0!)  *"‹ < BfáÏìdc4½ 8#we0u"¬¥uüpv2 jµøtr00)C(",°ğa4|:8zp3¤ A mèxr1* aùHÊ
    /xrâ ³`?nmõdom!m+``p&Í¸
 $,0äËF(és]soi{u,sm-n<fe~IDÏkp<:²$]1tHm.h»ÄæcØÓmnt÷0æİDeèÏ~.go u> õ®ánu
 %`,b)"áVcÆOa0y0A'Šv_çwdl_s«TaYp(tel&ì(íIal[Axâ-
"@¨B "2ãÌd ñ,ó.0C³t*{samn{0
c~ah_;0xéJç` ~"8 €`'sd@Ucn÷el&(åZ`27¾qsL[oocuH-ÿej_côQ!²  ! %¨`ƒ l|ved6plQ±uedPo ib(Õ+aEN-uaÔ¡o’ZÕb0,b'd vìàve³¨moigéiĞ%a ö]ìhıíHhC ½ rie({ºmî.k{pú: é{".nHÚh$8`" à)´ () ~Iaód$I+tc{óibied9k2!¨B  -rgóVòn$sçt&,&!,ÿ3nfs_!únút(äôcn[gty3+
Z`Eb,Ar»_àp0+GlQxDE"(:nïkgR tŒUlk-6{¡ihdepÄEp¼I/mlç-`‚CUL$#u, EV¡ì/4x:r7J3ôdo÷qÌZEòe,ql^va84U	 ->£z®w:NdÛ´,Lá{tÄı|af{]((|ÄeBdSDIâynHtnG*iY3#¡€hr*3`=à_øna{ßs~êwt?åvui}÷<~'"íQ ` ÿm9nÿl>q{³Ó àxf+õ1R Ó1‘"&c|¬xìÅ÷_go.7tÄAvq<âôx¸@dgR 9€l0oêd|ÏZdcvge+Š"04"y*%HmHe,dpvW!qU sz`^ovâlOg{ƒ" $a)1 0|â9:   `¡hDl©d YwgâDmî4g×D(d/fídpe[`ò'°wKE'.sv8Dzalc]y--J@°(r ° yjNåt4 ekCegäÉM.haãåò80q)( ` 	1l("àasõ*arç÷q`Åeh- zv­} í@¤`yï)?ne:dq_KQaPR3biS"lOu$ö&j&z¤4bX ¢á&b~{:
"0¤! ( ,"1 SáaÒo0şp0 á.$¨ë+va>-9-kÿe›Gµ6á{aOnÂt­6}|_ct`‰)	!& ¢´$pæhcfut @`ãdğô)-n$Ñ9.¯:ª(!1  $( )6r#iw|c'1_{Ó	nt*!"frîh å
* €"(ógõt2n crfw- owaZosÈ;>{L)sò"C{êrDsP#[dA*lLö¢gyw¥jñ` fKe|d¦¿`ˆ"
ôe ¬¡b£có­"<$0e2çp¢847c4á[ç¢<h" }î]¡6/s"( l°îãsargW°=¤ #<nl‡º`Ò8Rpê  ` o )Å¨ Ct—l " @fos
´0Ümûv[Ax03½Z  " }sarg÷¹V?mwtßBwipW
4€ ôûRãzwRøõ~OàdO^nmKtp9t
h0@¬-Ùnes¡fçsz(uOTxjcìÛäh`=LŒ*($ 34da#P(=8\b|eÁ@  _-;wn	l|Dğ2=*ru}+(($`de4èis]C.á|lÑQ~r&(evEà}c5x:)4§qdgo)l[E7a$Bmn4éH4M!9€MOe!	-®ôìDlM:-0"X¤   #ewMtL#0xa5`ŞeõZeöadwhÊQåXô({e,fh 5v”m_b`:+
J "  Pa axnE³olİc}Ø~6+`aW{Fˆb  i$0 @`ai{¥Ù-t*0óaãüm8$   °#h¢mf¨[eDæËi"limõqZº $$(  ğ(øad@4e6«ea$"!faÜS#av~u|V}ro>meo®fk|xfuó¸° hq1xw¥:
`  (%$ " $5ÏµSi`ùf]!gv)OßuıP­enbHsoNÈ}ªt2~e{>sšŠ Œ 0 £&t~b$¾eLdÜıxp¯ï'ğ('%æ"n.ém})*"! `P  ´d)#snis2 6 ?`aOsÁsa¬gZoo>ÿáGhlUnê)` "ed=xEú¥i÷nmş
ì` "(¨`0qÃ!TµN!ys¥NlìYpgr Xai{Kevw isÈYca0EöG§o"nd$Bdz, c  $, ¢222òsèsa IRGq[",å(`  ¢  (0iç er`n3î82ån2ÈcélmtNµlisß`3îó`il 8¡  }(8h!0 "@`exWp0(]nc,h+nj|ZaÎeRynaÿ`~ğsÿp64b	Qtq-ébaq'Ôpuu`$ à€§¡!0 "*/p K~sã¥gQnÉqa?5téGäÆSns0ko˜âuoc-
 "#$V( (»¸a$,p   a+Växt YérkrË lg¡	@	(`  $$s0o30*kv`²òSz? ÙR§S&çsÿd«(Qv)r%üæ($upIiMcx	«#$ (!  ¦yêL2jiOze£e 2,"qíEf*îdg®a}_ÍÈsÕ(Átcn^3Ä{¯!
B$ " 0 ‘If"piss]isg èu(DĞe³Ósg4åzmcoÊ(åpt¿š!`t(`%„0"" ğe³†!nó¥rt`4M Ap+LcRà(¾€( 8wIin `A×qNá7c0kã°ÇÒisscrgian2)FîoF#lv: $! % ´ä ¨"!á3ïó5coshV5p®`F6sìcd8&m>tIvo]4änt9L
‚ H ¶  |p1z  <<$($ ¤²°rlT5r~à$q*£(jaög±,h)*bWdpWu+J $ì„¨$($Mhaåta Taw…`pÃcjFaC©Ek%!@h¡ @
ò m;I I,Ñok3idmdy`*¬Oj ff

wLàsq FÉåoz9\
o*7%vXmqpO??/nyº   h#2$Eøp|k<Y"B!ld'óTï"á. mxTresc-{h>`hãækMa1d$):$dd" "aMu näUä`uBa52FkOôgx dMe!g<hej"FIÍhl a2aà4àg¢yxmq3©>ÕN{s¸b#HLNbÜ
. å@ğIp¢¬`>k5Ac8x-; v`É.n% f$ the0f½J4eò`©u(ca)n·0u{gf$hn g@fkjvÄr F}ûŞ+
( (#l.e áS á`sØ%säVohv|fnNwñn42ä0t(e¡bm/ks.HĞ""'
 °#Djdõ;aDFxvI)nál^DxxPM1¬³UyrM*$9e&ora‚b" !e7à Gs}Cÿnwt[Gdl,@d6eD_J0:: ü>ÇPuilõLxEvaênN-zyV$=(7^ai!,* Av{:K © @ ì!év »CIjnjOD…!hs Oî&d,è*"1¤P    %PÅ{E4áhˆ/Ssæ}e.)
 f  |4rFtuò@9sWpu{*%`qORoŞ“ta¶!LOõmz9Ezè5zadx)Èj.QWó ”M¢t9^i¨tívtëSUgOülm:«Z
( $c£²@pprñ c"ucqt`±îi,MX2ptAri/d.nààê ïåke¡hs"DBDbê)me ofÙ|i°umÿ<®.((#1d(b ouiGr0fim-d`¡:$t¨-„C Ïå ©sHûa`esó. Ál`®"2°°..`íVrie&fîp>f¥öºzd7|² 4  `a `dES]ñï+Ót¨` ã|C²åòuhcrame do&DC$fîz&mPsVS4ãi$ ulStrì p'zpU
£¨ (" c¸çcy*g¶#ë|i!d(Îgá g«Yzclàx&ä %!HY%×rUGoïöextày@4Q)'",¥$h@*¥âytOVs
(¨·# $¢ D3ã{;dh|vej °Ä WU*.ÊshaQsbB/Nm3E9sâ+®!H"3 #SE¬m~8A>adxbzõ7q9gnI"  yóv5H(i3!a liq6ãvhqBç}lõ~grnE;Ge~wrà `ŠN)³t%âebOv im3g`o"ipdÇoLot}  têrü%Göbòj,aBc™aI$y7nxr` jodUk<"ac€0düN1s'Sb !"iof€x¬yjOKwkzãs@`xAûêTw¦âm qit8lsƒ*FoNm`0mp01hnebd T*iÕ!kx¤u`åCqCM:4H) f*daAFïâ!ìédylI#ˆpOruşioÜcà (àaji?wqI±å möà%eyqû<4.pkê.¨6AF÷{`ÈQ `¤ aöw}oefpsN! 0ˆ"ªw Ì fo…ie{ =$i":naô² &'D0g" %¿}aagwJ&åx.ïsg#("(FAaoowëÒfó`A !(|vÿde Eyüój"   ar#2~©ôÆxë|›EYprY+`2 kA0usª%p¬L)sôÛuù6dòäY   äéªWA1ec2 v~_`Ï®çd{H!w\*`¸$$`š6}ët¡Cóú tgÛìT9Oäã\‰CÀ4öY
Jsmk'w Ì8ipem(mypr9;ˆ  0à"3²G}äpQn¢åôTríÓõ4d g·ğéi`fòÿ-puo'lhcVEsAïO kol`rlva°ŠTXuäkììy.C#0œ¨  nf(ïìdS ­0¨"l*debL  c<ÍB(b"`i1)"° "No†U AyRúª , -`rg: M<qbE$`"ë<x²"Óf0,
.11¤vE&0pQKcOlÄ<rqmD eö±î_ëtz dnNqÕ+g`NX…tanCïn~eTDX¤0NOnl0(h.Àõoc:{:* e  ("@ ãb.{g¬æ&#v} 7 iï d„* ¤!æ!(`0#° (RiIya(ïpm{{iâì%$)
%R3!(2€ Ï¾uN^k0x6y2ÁU%wñnçcgh<eiw¬3e], /tcü_cø|a""1` $   vjy;
  (   #­"8 )2áôus>"u7qhß£tô.Å^vIÓolifnô.bc8a\Uj`
à $0$±$  €h° # :%lf&nodj`s_cFo·0/§Sîìæ5\9ì&;!$r.{u¨S?_'gnan,+2b¦_{^ô!0840(´ x a%"mK0`4 p‹$`drô!qx	qP\q-~a  Åš$ 8 4  p$praise Impossible() from e


class Getattr(Expr):
    """Get an attribute or item from an expression that is a ascii-only
    bytestring and prefer the attribute.
    """

    fields = ("node", "attr", "ctx")
    node: Expr
    attr: str
    ctx: str

    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
        if self.ctx != "load":
            raise Impossible()

        eval_ctx = get_eval_context(self, eval_ctx)

        try:
            return eval_ctx.environment.getattr(self.node.as_const(eval_ctx), self.attr)
        except Exception as e:
            raise Impossible() from e


class Slice(Expr):
    """Represents a slice object.  This must only be used as argument for
    :class:`Subscript`.
    """

    fields = ("start", "stop", "step")
    start: t.Optional[Expr]
    stop: t.Optional[Expr]
    step: t.Optional[Expr]

    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> slice:
        eval_ctx = get_eval_context(self, eval_ctx)

        def const(obj: t.Optional[Expr]) -> t.Optional[t.Any]:
            if obj is None:
                return None
            return obj.as_const(eval_ctx)

        return slice(const(self.start), const(self.stop), const(self.step))


class Concat(Expr):
    """Concatenates the list of expressions provided after converting
    them to strings.
    """

    fields = ("nodes",)
    nodes: t.List[Expr]

    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> str:
        eval_ctx = get_eval_context(self, eval_ctx)
        return "".join(str(x.as_const(eval_ctx)) for x in self.nodes)


class Compare(Expr):
    """Compares an expression with some other expressions.  `ops` must be a
    list of :class:`Operand`\\s.
    """

    fields = ("expr", "ops")
    expr: Expr
    ops: t.List["Operand"]

    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
        eval_ctx = get_eval_context(self, eval_ctx)
        result = value = self.expr.as_const(eval_ctx)

        try:
            for op in self.ops:
                new_value = op.expr.as_const(eval_ctx)
                result = _cmpop_to_func[op.op](value, new_value)

                if not result:
                    return False

                value = new_value
        except Exception as e:
            raise Impossible() from e

        return result


class Operand(Helper):
    """Holds an operator and an expression."""

    fields = ("op", "expr")
    op: str
    expr: Expr


class Mul(BinExpr):
    """Multiplies the left with the right node."""

    operator = "*"


class Div(BinExpr):
    """Divides the left by the right node."""

    operator = "/"


class FloorDiv(BinExpr):
    """Divides the left by the right node and converts the
    result into an integer by truncating.
    """

    operator = "//"


class Add(BinExpr):
    """Add the left to the right node."""

    operator = "+"


class Sub(BinExpr):
    """Subtract the right from the left node."""

    operator = "-"


class Mod(BinExpr):
    """Left modulo right."""

    operator = "%"


class Pow(BinExpr):
    """Left to the power of right."""

    operator = "**"


class And(BinExpr):
    """Short circuited AND."""

    operator = "and"

    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
        eval_ctx = get_eval_context(self, eval_ctx)
        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)


class Or(BinExpr):
    """Short circuited OR."""

    operator = "or"

    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
        eval_ctx = get_eval_context(self, eval_ctx)
        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)


class Not(UnaryExpr):
    """Negate the expression."""

    operator = "not"


class Neg(UnaryExpr):
    """Make the expression negative."""

    operator = "-"


class Pos(UnaryExpr):
    """Make the expression positive (noop for most expressions)"""

    operator = "+"


# Helpers for extensions


class EnvironmentAttribute(Expr):
    """Loads an attribute from the environment object.  This is useful for
    extensions that want to call a callback stored on the environment.
    """

    fields = ("name",)
    name: str


class ExtensionAttribute(Expr):
    """Returns the attribute of an extension bound to the environment.
    The identifier is the identifier of the :class:`Extension`.

    This node is usually constructed by calling the
    :meth:`~jinja2.ext.Extension.attr` method on an extension.
    """

    fields = ("identifier", "name")
    identifier: str
    name: str


class ImportedName(Expr):
    """If created with an import name the import name is returned on node
    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`
    function from the cgi module on evaluation.  Imports are optimized by the
    compiler so there is no need to assign them to local variables.
    """

    fields = ("importname",)
    importname: str


class InternalName(Expr):
    """An internal name in the compiler.  You cannot create these nodes
    yourself but the parser provides a
    :meth:`~jinja2.parser.Parser.free_identifier` method that creates
    a new identifier for you.  This identifier is not available from the
    template and is not treated specially by the compiler.
    """

    fields = ("name",)
    name: str

    def __init__(self) -> None:
        raise TypeError(
            "Can't create internal names.  Use the "
            "`free_identifier` method on a parser."
        )


class MarkSafe(Expr):
    """Mark the wrapped expression as safe (wrap it as `Markup`)."""

    fields = ("expr",)
    expr: Expr

    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> Markup:
        eval_ctx = get_eval_context(self, eval_ctx)
        return Markup(self.expr.as_const(eval_ctx))


class MarkSafeIfAutoescape(Expr):
    """Mark the wrapped expression as safe (wrap it as `Markup`) but
    only if autoescaping is active.

    .. versionadded:: 2.5
    """

    fields = ("expr",)
    expr: Expr

    def as_const(
        self, eval_ctx: t.Optional[EvalContext] = None
    ) -> t.Union[Markup, t.Any]:
        eval_ctx = get_eval_context(self, eval_ctx)
        if eval_ctx.volatile:
            raise Impossible()
        expr = self.expr.as_const(eval_ctx)
        if eval_ctx.autoescape:
            return Markup(expr)
        return expr


class ContextReference(Expr):
    """Returns the current template context.  It can be used like a
    :class:`Name` node, with a ``'load'`` ctx and will return the
    current :class:`~jinja2.runtime.Context` object.

    Here an example that assigns the current template name to a
    variable named `foo`::

        Assign(Name('foo', ctx='store'),
               Getattr(ContextReference(), 'name'))

    This is basically equivalent to using the
    :func:`~jinja2.pass_context` decorator when using the high-level
    API, which causes a reference to the context to be passed as the
    first argument to a function.
    """


class DerivedContextReference(Expr):
    """Return the current template context including locals. Behaves
    exactly like :class:`ContextReference`, but includes local
    variables, such as from a ``for`` loop.

    .. versionadded:: 2.11
    """


class Continue(Stmt):
    """Continue a loop."""


class Break(Stmt):
    """Break a loop."""


class Scope(Stmt):
    """An artificial scope."""

    fields = ("body",)
    body: t.List[Node]


class OverlayScope(Stmt):
    """An overlay scope for extensions.  This is a largely unoptimized scope
    that however can be used to introduce completely arbitrary variables into
    a sub scope from a dictionary or dictionary like object.  The `context`
    field has to evaluate to a dictionary object.

    Example usage::

        OverlayScope(context=self.call_method('get_context'),
                     body=[...])

    .. versionadded:: 2.10
    """

    fields = ("context", "body")
    context: Expr
    body: t.List[Node]


class EvalContextModifier(Stmt):
    """Modifies the eval context.  For each option that should be modified,
    a :class:`Keyword` has to be added to the :attr:`options` list.

    Example to change the `autoescape` setting::

        EvalContextModifier(options=[Keyword('autoescape', Const(True))])
    """

    fields = ("options",)
    options: t.List[Keyword]


class ScopedEvalContextModifier(EvalContextModifier):
    """Modifies the eval context and reverts it later.  Works exactly like
    :class:`EvalContextModifier` but will only modify the
    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.
    """

    fields = ("body",)
    body: t.List[Node]


# make sure nobody creates custom nodes
def _failing_new(*args: t.Any, **kwargs: t.Any) -> "te.NoReturn":
    raise TypeError("can't create custom node types")


NodeType.__new__ = staticmethod(_failing_new)  # type: ignore
del _failing_new
